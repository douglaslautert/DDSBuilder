id;title;description;vendor;published;cvss_score;severity;attack_vector;cwe_category;cwe_explanation;source
NVD:CVE-2021-43547;CVE-2021-43547;TwinOaks Computing CoreDX DDS versions prior to 5.9.1 are susceptible to exploitation when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;CoreDX DDS;05/05/2022 17:15;82;HIGH;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description highlights that an attacker can exploit the vulnerability by sending crafted packets to consume resources (bandwidth) on target devices, leading to a denial-of-service condition.;Vulners
CVE-2021-43547;CVE-2021-43547;TwinOaks Computing CoreDX DDS versions prior to 5.9.1 are susceptible to exploitation when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;CoreDX DDS;05/05/2022 17:15;82;HIGH;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption, as it allows an attacker to flood the target devices, leading to denial of service. This is a classic example of resource exhaustion.;Vulners
PRION:CVE-2021-43547;Design/Logic Flaw;TwinOaks Computing CoreDX DDS versions prior to 5.9.1 are susceptible to exploitation when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;CoreDX DDS;05/05/2022 17:15;85;;;CWE-400;Uncontrolled Resource Consumption: The vulnerability allows an attacker to send a specially crafted packet, leading to excessive resource consumption (traffic flooding) and potentially a denial of service.;Vulners
CVELIST:CVE-2021-43547;CVE-2021-43547 TwinOaks Computing CoreDX DDS Secure Network Amplification;TwinOaks Computing CoreDX DDS versions prior to 5.9.1 are susceptible to exploitation when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;CoreDX DDS;05/05/2022 15:19;75;HIGH;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description indicates that the vulnerability allows an attacker to send crafted packets that consume excessive resources (bandwidth), leading to a denial-of-service condition.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";Fast DDS;01/02/2022 12:00;98;CRITICAL;;CWE-788;This vulnerability stems from issues like 'Write-what-where Condition', 'Incorrect Calculation of Buffer Size', 'Heap-based Buffer Overflow', and 'Stack-based Buffer Overflow', all pointing to a failure to properly manage buffer boundaries.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";Fast DDS;01/02/2022 12:00;98;CRITICAL;;CWE-788;Similar to Eclipse, the mention of buffer overflow vulnerabilities indicates a potential weakness in buffer management.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";Gurum DDS;01/02/2022 12:00;98;CRITICAL;;CWE-788;As with the others, 'Network Amplification' coupled with the buffer overflow issues strongly suggests problems with handling buffer sizes effectively.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";RTI Connext DDS;01/02/2022 12:00;98;CRITICAL;;CWE-788;Again, the description highlighting buffer overflows points to vulnerabilities related to improper management of buffer sizes.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";RTI Connext DDS;01/02/2022 12:00;98;CRITICAL;;CWE-788;The report's mention of buffer overflow vulnerabilities clearly implicates issues with managing buffer boundaries within their DDS implementations.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";CoreDX DDS;01/02/2022 12:00;98;CRITICAL;;CWE-788;The emphasis on buffer overflow issues strongly indicates vulnerabilities related to the mismanagement of buffer sizes in their DDS implementations.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";All vendors;01/02/2022 12:00;98;CRITICAL;;CWE-120;This CWE specifically addresses buffer overflows, which are directly mentioned as vulnerabilities in the report.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";All vendors;01/02/2022 12:00;98;CRITICAL;;CWE-20;The 'Improper Handling of Syntactically Invalid Structure' and 'Improper Handling of Length Parameter Inconsistency' suggest potential failures in input validation.;Vulners
ICSA-21-315-02;Multiple Data Distribution Service (DDS) Implementations (Update A);"EXECUTIVE SUMMARY

  * **CVSS v3 8.6**
  * **ATTENTION:** Exploitable remotely/low attack complexity
  * **Vendors:** Eclipse, eProsima, GurumNetworks, Object Computing, Inc. (OCI), Real-Time Innovations (RTI), TwinOaks Computing
  * **Equipment:** CycloneDDS, FastDDS, GurumDDS, OpenDDS, Connext DDS Professional, Connext DDS Secure, Connext DDS Micro, CoreDX DDS
  * **Vulnerabilities:** Write-what-where Condition, Improper Handling of Syntactically Invalid Structure, Network Amplification, Incorrect Calculation of Buffer Size, Heap-based Buffer Overflow, Improper Handling of Length Parameter Inconsistency, Amplification, Stack-based Buffer Overflow



CISA is aware of a public report detailing vulnerabilities found in multiple open-source and proprietary Object Management Group (OMG) Data-Distribution Service (DDS) implementations...";All vendors;01/02/2022 12:00;98;CRITICAL;;CWE-400;'Network Amplification' and 'Amplification' vulnerabilities highlight the potential for attackers to exploit these flaws to amplify the impact of their attacks.;Vulners
NVD:CVE-2021-38439;CVE-2021-38439;All versions of GurumDDS are vulnerable to heap-based buffer overflow, which may cause a denial-of-service condition or remotely execute arbitrary code.;Gurum DDS;05/05/2022 17:15;98;CRITICAL;;CWE-122;Heap-based buffer overflows (CWE-122) occur when data written to a buffer allocated on the heap exceeds the buffer's boundaries, potentially overwriting critical data and allowing for arbitrary code execution or denial of service.;Vulners
CVE-2021-38439;CVE-2021-38439;All versions of GurumDDS are vulnerable to heap-based buffer overflow, which may cause a denial-of-service condition or remotely execute arbitrary code.;Gurum DDS;05/05/2022 17:15;98;CRITICAL;;CWE-122;CWE-122 represents a Heap-Based Buffer Overflow, which occurs when content intended for a specific portion of memory on the heap exceeds its allocated bounds, potentially overwriting adjacent data and leading to crashes or code execution.;Vulners
NVD:CVE-2021-38423;CVE-2021-38423;All versions of GurumDDS improperly calculate the size to be used when allocating the buffer, which may result in a buffer overflow.;Gurum DDS;05/05/2022 17:15;98;CRITICAL;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when a program writes data outside the allocated memory space on the heap, potentially leading to data corruption, crashes, or arbitrary code execution.;Vulners
CVE-2021-38423;CVE-2021-38423;All versions of GurumDDS improperly calculate the size to be used when allocating the buffer, which may result in a buffer overflow.;Gurum DDS;05/05/2022 17:15;98;CRITICAL;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when a program writes data past the boundaries of a fixed-size buffer, potentially leading to code execution or other unexpected behavior. In this case, the improper calculation of the buffer size during allocation allows for writing beyond the allocated memory space.;Vulners
PRION:CVE-2021-38423;Buffer overflow;All versions of GurumDDS improperly calculate the size to be used when allocating the buffer, which may result in a buffer overflow.;Gurum DDS;05/05/2022 17:15;75;;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input), also known as 'Classic Buffer Overflow,'  occurs when data is copied to a buffer without ensuring the copied data fits within the buffer's boundaries.  In this case, GurumDDS miscalculates the buffer size, potentially leading to an overflow during allocation.;Vulners
PRION:CVE-2021-38439;Heap overflow;All versions of GurumDDS are vulnerable to heap-based buffer overflow, which may cause a denial-of-service condition or remotely execute arbitrary code.;Gurum DDS;05/05/2022 17:15;75;;;CWE-1291;Heap-based Buffer Overflow occurs when a program writes data past the allocated buffer size on the heap, which can lead to memory corruption, crashes, and potential code execution.;Vulners
CVELIST:CVE-2021-38423;CVE-2021-38423 GurumDDS Heap-based Incorrect Calculation of Buffer Size;All versions of GurumDDS improperly calculate the size to be used when allocating the buffer, which may result in a buffer overflow.;Gurum DDS;05/05/2022 15:23;66;MEDIUM;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs because the software performs an operation on a buffer, but it can read from or write to a portion of memory that is outside of the intended buffer.;Vulners
CVELIST:CVE-2021-38439;CVE-2021-38439 GurumDDS Heap-based Buffer Overflow;All versions of GurumDDS are vulnerable to heap-based buffer overflow, which may cause a denial-of-service condition or remotely execute arbitrary code.;Gurum DDS;05/05/2022 15:14;86;HIGH;;CWE-122;Heap-based buffer overflow occurs when content intended for a specific portion of memory, allocated during runtime (the heap), overflows into adjacent memory locations due to insufficient bounds checking. This can lead to data corruption, crashes, or even remote code execution.;Vulners
NVD:CVE-2024-31680;CVE-2024-31680;File Upload vulnerability in Shibang Communications Co., Ltd. IP network intercom broadcasting system v.1.0 allows a local attacker to execute arbitrary code via the my_parser.php component.;CoreDX DDS;17/04/2024 00:15;88;HIGH;;CWE-434;CWE-434 (Unrestricted Upload of File with Dangerous Type) occurs when an application allows an attacker to upload or transfer files of dangerous types that can be automatically processed by the web server or other software in a way that executes contained code.;Vulners
CVE-2024-31680;CVE-2024-31680;File Upload vulnerability in Shibang Communications Co., Ltd. IP network intercom broadcasting system v.1.0 allows a local attacker to execute arbitrary code via the my_parser.php component.;CoreDX DDS;17/04/2024 00:15;88;HIGH;;CWE-434;Unrestricted Upload of File with Dangerous Type. This vulnerability occurs when the application allows an attacker to upload or transfer files of dangerous types, which can then be executed on the server.;Vulners
CVELIST:CVE-2024-31680;CVE-2024-31680;File Upload vulnerability in Shibang Communications Co., Ltd. IP network intercom broadcasting system v.1.0 allows a local attacker to execute arbitrary code via the my_parser.php component.;CoreDX DDS;16/04/2024 00:00;0;NONE;;CWE-434;Unrestricted Upload of File with Dangerous Type. The software allows the upload of files with dangerous types that can be automatically interpreted and executed on the server.;Vulners
VULNRICHMENT:CVE-2024-31680;CVE-2024-31680;File Upload vulnerability in Shibang Communications Co., Ltd. IP network intercom broadcasting system v.1.0 allows a local attacker to execute arbitrary code via the my_parser.php component.;CoreDX DDS;16/04/2024 00:00;0;NONE;;CWE-434;CWE-434 (Unrestricted Upload of File with Dangerous Type) occurs when an application allows an attacker to upload or transfer files of dangerous types that can be executed or interpreted by the system. In this case, the vulnerability in the 'my_parser.php' component allows arbitrary code execution.;Vulners
NVD:CVE-2024-3218;CVE-2024-3218;A vulnerability classified as critical has been found in Shibang Communications IP Network Intercom Broadcasting System 1.0. This affects an unknown part of the file /php/busyscreenshotpush.php. The manipulation of the argument jsondata[callee]/jsondata[imagename] leads to path traversal: '../filedir'. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-259065 was assigned to this vulnerability.;CoreDX DDS;03/04/2024 00:15;54;MEDIUM;;CWE-22;CWE-22 (Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')) occurs when software constructs a pathname from user-supplied input, allowing the attacker to access files outside of the intended directory. This is exactly what the description illustrates.;Vulners
CVE-2024-3218;CVE-2024-3218;A vulnerability classified as critical has been found in Shibang Communications IP Network Intercom Broadcasting System 1.0. This affects an unknown part of the file /php/busyscreenshotpush.php. The manipulation of the argument jsondata[callee]/jsondata[imagename] leads to path traversal: '../filedir'. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-259065 was assigned to this vulnerability.;CoreDX DDS;03/04/2024 00:15;54;MEDIUM;;CWE-22;CWE-22 (Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')) occurs when software constructs a path to a file or directory using user-supplied input that is not properly validated, allowing an attacker to access files or directories outside the intended scope.;Vulners
CVELIST:CVE-2024-3218;CVE-2024-3218 Shibang Communications IP Network Intercom Broadcasting System busyscreenshotpush.php path traversal;A vulnerability classified as critical has been found in Shibang Communications IP Network Intercom Broadcasting System 1.0. This affects an unknown part of the file /php/busyscreenshotpush.php. The manipulation of the argument jsondata[callee]/jsondata[imagename] leads to path traversal: '../filedir'. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-259065 was assigned to this vulnerability.;CoreDX DDS;02/04/2024 23:31;54;MEDIUM;;CWE-22;Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal');Vulners
VULNRICHMENT:CVE-2024-3218;CVE-2024-3218 Shibang Communications IP Network Intercom Broadcasting System busyscreenshotpush.php path traversal;A vulnerability classified as critical has been found in Shibang Communications IP Network Intercom Broadcasting System 1.0. This affects an unknown part of the file /php/busyscreenshotpush.php. The manipulation of the argument jsondata[callee]/jsondata[imagename] leads to path traversal: '../filedir'. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The identifier VDB-259065 was assigned to this vulnerability.;CoreDX DDS;02/04/2024 23:31;54;MEDIUM;;CWE-22;CWE-22 (Improper Limitation of a Path Traversal Input) occurs when an application allows user-supplied input to access files or directories outside the intended scope. This vulnerability arises from insufficient validation or sanitization of user-provided paths.;Vulners
CVE-2019-14365;CVE-2019-14365;The Intercom plugin through 1.2.1 for WordPress leaks a Slack Access Token in source code. An attacker can obtain a lot of information about the victim's Slack (channels, members, etc.).;Intercom DDS;12/11/2019 21:15;75;HIGH;;CWE-522;This vulnerability involves the improper storage of sensitive information, such as the Slack Access Token, directly within the source code, making it easily accessible to attackers.;Vulners
NVD:CVE-2019-14365;CVE-2019-14365;The Intercom plugin through 1.2.1 for WordPress leaks a Slack Access Token in source code. An attacker can obtain a lot of information about the victim's Slack (channels, members, etc.).;Intercom DDS;12/11/2019 21:15;75;HIGH;;CWE-522;This vulnerability falls under CWE-522: Insufficiently Protected Credentials. The Intercom plugin for Wordpress inadvertently exposed a Slack Access Token in its source code, making it easily accessible to attackers. This weakness stems from a failure to adequately protect sensitive credentials.;Vulners
PRION:CVE-2019-14365;Code injection;The Intercom plugin through 1.2.1 for WordPress leaks a Slack Access Token in source code. An attacker can obtain a lot of information about the victim's Slack (channels, members, etc.).;Intercom DDS;12/11/2019 21:15;50;;;CWE-522;This vulnerability involves the Intercom plugin storing sensitive information, a Slack Access Token, directly in the source code. CWE-522 (Insufficiently Protected Credentials) addresses cases where credentials are not adequately protected, making them retrievable from the client-side source code.;Vulners
CVELIST:CVE-2019-14365;CVE-2019-14365;The Intercom plugin through 1.2.1 for WordPress leaks a Slack Access Token in source code. An attacker can obtain a lot of information about the victim's Slack (channels, members, etc.).;Intercom DDS;12/11/2019 20:47;0;NONE;;CWE-522;CWE-522 (Insufficiently Protected Credentials or Keys) occurs because the Intercom plugin for WordPress inadvertently exposes a Slack Access Token within its source code. This vulnerability allows attackers to potentially extract sensitive information and gain unauthorized access to the victim's Slack workspace.;Vulners
WPVDB-ID:5CEC0600-9B6D-47D7-9AF5-1A126A5E9A8E;WP Intercom Slack <= 1.2.2 - Slack Access Token Disclosure;"The Intercom plugin through 1.2.2 leaks a Slack Access Token in source code. An attacker can obtain a lot of information about the victim's Slack (channels, members, etc.).
";Intercom DDS;12/11/2019 00:00;50;;;CWE-200;This vulnerability falls under CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The Intercom plugin inadvertently exposes the Slack Access Token within its source code, allowing unauthorized individuals to potentially access and exploit sensitive information from the victim's Slack workspace.;Vulners
VERACODE:5884;Insecure Logout;"intercom-rails is vulnerable to insecure logouts. The library does not delete cookies on a user logging out, meaning that users aren't properly signed out, allowing a malicious user to access the system as a different user.
";Intercom DDS;05/03/2018 09:59;0;;;CWE-613;This vulnerability falls under CWE-613: Insufficient Session Expiration. The description highlights that the 'intercom-rails' library fails to clear session cookies upon user logout.  This could allow an attacker to reuse existing cookies to hijack a user's session if they gain access to the victim's browser or network.;Vulners
OBB:282348;alphacommunications.com XSS vulnerability ;"##### Vulnerable URL:
    
    
    https://www.alphacommunications.com/search.php?find=Intercom+Set&find;=suresh""/>
    

##### Details:

Description| Value  
---|---  
Patched:| No  
Latest check for patch:| 24.11.2017  
Vulnerability type:| XSS  
Vulnerability status:| Publicly disclosed  
Alexa Rank| 1626790  
VIP website status:| No  
Check alphacommunications.com SSL connection:| (Grade: A)  
  
##### Coordinated Disclosure Timeline:

Description| Value  
---|---  
Vulnerability submitted via Open Bug Bounty| 26 August, 2017 12:57 GMT  
Generic security notifications sent to website owner| 26 August, 2017 12:59 GMT  
Notification sent to subscribers (without technical details)| 26 August, 2017 14:17 GMT  
Vulnerability details disclosed by researcher| 24 November, 2017 13:23 GMT
...";Intercom DDS;26/08/2017 12:57;0;;;CWE-79;The vulnerability described is a Cross-Site Scripting (XSS) vulnerability. CWE-79 (Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')) covers scenarios where untrusted user input is not properly sanitized before being included in an HTML response.;Vulners
H1:234947;Cuvva: Sensitive Support Mail Disclosure;An issue with our handling of Intercom sessions existed in one of our partner dashboards. Exact details being kept under wraps for now, as it's an issue which exists in a large number of Intercom installations.;Intercom DDS;31/05/2017 16:49;0;;;CWE-306;This vulnerability description mentions an 'issue with handling Intercom sessions,' which strongly suggests a problem with authentication and session management (CWE-306). While specifics are absent, exploiting session vulnerabilities could allow attackers to hijack user sessions.;Vulners
VERACODE:3862;Cross-site Scripting (XSS);"intercom-rails is vulnerable to cross-site scripting (XSS) attacks. These attacks are possible through the script tags in intercom settings.
";Intercom DDS;07/04/2017 07:48;0;;;CWE-79;CWE-79 (Cross-site Scripting) occurs when an application includes untrusted user input in its output without proper validation or escaping. This allows attackers to execute malicious scripts in the victim's browser.;Vulners
VERACODE:3219;Cross-Site Scripting (XSS);"intercom-rails is vulnerable to cross-site scripting (XSS) attacks. A malicious user can inject or execute arbitrary script by pre-appending script tags before the arbitrary script in their data.
";Intercom DDS;04/01/2017 01:22;0;;;CWE-79;This vulnerability falls under CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'). The description clearly states that arbitrary script can be injected and potentially executed, which is the hallmark of a cross-site scripting vulnerability.;Vulners
CVE-2014-3881;CVE-2014-3881;Cross-site request forgery (CSRF) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to hijack the authentication of arbitrary users.;Intercom DDS;28/06/2014 00:55;68;MEDIUM;;CWE-352;This vulnerability falls under CWE-352: Cross-Site Request Forgery (CSRF). CSRF vulnerabilities exploit the trust a web application has in a user's browser, allowing an attacker to force the user's browser to send requests to the application without the user's knowledge or consent.;Vulners
NVD:CVE-2014-3881;CVE-2014-3881;Cross-site request forgery (CSRF) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to hijack the authentication of arbitrary users.;Intercom DDS;28/06/2014 00:55;68;MEDIUM;;CWE-352;Cross-Site Request Forgery (CSRF) is a type of vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform.;Vulners
NVD:CVE-2014-2006;CVE-2014-2006;Cross-site scripting (XSS) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.;Intercom DDS;28/06/2014 00:55;43;MEDIUM;;CWE-79;CWE-79 (Cross-site Scripting) occurs when an application includes untrusted data in an HTML response sent to a web browser. This allows attackers to execute malicious scripts in a victim's browser, potentially stealing their session, defacing websites, or redirecting the user to malicious sites.;Vulners
CVE-2014-2006;CVE-2014-2006;Cross-site scripting (XSS) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.;Intercom DDS;28/06/2014 00:55;43;MEDIUM;;CWE-79;CWE-79 (Cross-site Scripting) occurs when an application allows untrusted user data to be dynamically included in web pages without proper validation or escaping. This allows attackers to execute malicious scripts in the victim's browser.;Vulners
PRION:CVE-2014-2006;Cross site scripting;Cross-site scripting (XSS) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.;Intercom DDS;28/06/2014 00:55;43;;;CWE-79;This vulnerability falls under CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'). This is because the description explicitly states that the vulnerability allows attackers to inject arbitrary web script or HTML, indicating a failure to properly sanitize user input.;Vulners
PRION:CVE-2014-3881;Cross site request forgery (csrf);Cross-site request forgery (CSRF) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to hijack the authentication of arbitrary users.;Intercom DDS;28/06/2014 00:55;68;;;CWE-352;CWE-352 refers to Cross-Site Request Forgery (CSRF).  In this case, the software doesn't have adequate protection to prevent attackers from forcing authenticated users to perform actions without their knowledge by sending them malicious requests.;Vulners
CVELIST:CVE-2014-2006;CVE-2014-2006;Cross-site scripting (XSS) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.;Intercom DDS;28/06/2014 00:00;0;NONE;;CWE-79;CWE-79 (Cross-site Scripting) occurs when an application allows untrusted user data to be interpreted as code by the web browser. This can allow attackers to steal user data, deface websites, or launch phishing attacks.;Vulners
CVELIST:CVE-2014-3881;CVE-2014-3881;Cross-site request forgery (CSRF) vulnerability in Intercom Web Kyukincho 3.x before 3.0.030 allows remote attackers to hijack the authentication of arbitrary users.;Intercom DDS;28/06/2014 00:00;0;NONE;;CWE-352;Cross-site request forgery (CSRF) occurs when an attacker tricks a victim into submitting a malicious request on a web application. This can allow the attacker to perform actions as the victim, such as changing account details or making purchases.;Vulners
JVN:36259412;JVN#36259412: Web Kyukincho vulnerable to cross-site request forgery;"Web Kyukincho provided by Intercom, Inc. Web Kyukincho contains a cross-site request forgery vulnerability.

 ## Impact

If a user views a malicious page while logged in, unintended operations may be conducted...";Intercom DDS;25/06/2014 00:00;68;MEDIUM;;CWE-352;Cross-Site Request Forgery (CSRF) is a type of web application vulnerability that allows an attacker to induce users to perform actions they did not intend to perform.;Vulners
JVN:80006084;JVN#80006084: Web Kyukincho vulnerable to cross-site scripting;Web Kyukincho provided by Intercom, Inc. Web Kyukincho contains a cross-site scripting vulnerability...;Intercom DDS;25/06/2014 00:00;43;MEDIUM;;CWE-79;This vulnerability falls under CWE-79 (Cross-site Scripting), which occurs when untrusted user input is not properly sanitized and is then included in a web page that is sent to the user's browser.  This allows attackers to execute malicious scripts in victimsï¿½ browsers, potentially hijacking user sessions, stealing sensitive information, or redirecting users to malicious websites.;Vulners
NMAP:ENIP-INFO.NSE;enip-info NSE Script;"Information that is parsed includes Device Type, Vendor ID, Product name, Serial Number, Product code, Revision Number, status, state, as well as the Device IP. 

This script was written based of information collected by using the the Wireshark dissector for CIP, and EtherNet/IP, The original information was collected by running a modified version of the ethernetip.py script (<https://github.com/paperwork/pyenip>) 

<http://digitalbond.com>

##  Example Usage 
    
    
    nmap --script enip-info -sU -p 44818 <host>
    
    

##  Script Output 
    
    
    PORT		STATE	SERVICE			REASON
    44818/tcp open 	EtherNet-IP-2	syn-ack
    | enip-info:
    |   type: Communications Adapter (12)
    |   vendor: Rockwell Automation/Allen-Bradley (1)
    |   productName: 1769-L32E Ethernet Port
    |   serialNumber: 0x000000
    |   productCode: 158
    |   revision: 3.7
    |   status: 0x0030
    |   state: 0x03
    |_  ipAddress: 192.168.1.123

##  Requires 

  * [ipOps](<../lib/ipOps.html>)
  * [nmap](<../lib/nmap.html>)
  * [shortport](<../lib/shortport.html>)
  * [stdnse](<../lib/stdnse.html>)
  * [string](<>)

* * *
...";RTI Connext DDS;22/05/2014 18:25;100;;;CWE-212;The Nmap script outputs detailed device information including Vendor ID, Product name, Serial Number, Product code, and Revision Number. This information could be leveraged by an attacker to fingerprint the device, identify vulnerabilities, and plan further attacks.;Vulners
CVE-2024-30259;CVE-2024-30259;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet, heap buffer overflow occurs on the subscriber. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs as the vulnerability allows an attacker to overflow a buffer on the heap by sending a malformed RTPS packet, potentially leading to remote code execution.;Vulners
DEBIANCVE:CVE-2024-30259;CVE-2024-30259;FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet, heap buffer overflow occurs on the subscriber. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.;Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when the code writing to a heap buffer overruns the buffer's boundary, potentially overwriting adjacent data or executing arbitrary code.;Vulners
NVD:CVE-2024-30259;CVE-2024-30259;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet, heap buffer overflow occurs on the subscriber. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-122;This vulnerability is due to a heap buffer overflow, which occurs when data is written outside the allocated memory space of the heap. Attackers can exploit this by crafting malformed RTPS packets to cause a crash, leading to a denial of service.;Vulners
DEBIANCVE:CVE-2024-30258;CVE-2024-30258;FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS` packet, the subscriber crashes when creating `pthread`. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.;Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-120;This vulnerability involves a buffer overflow, occurring when FastDDS attempts to create a pthread (POSIX thread) without properly handling a malformed RTPS packet. This could allow an attacker to crash the subscriber process, leading to a denial of service.;Vulners
CVE-2024-30258;CVE-2024-30258;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS` packet, the subscriber crashes when creating `pthread`. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";RTI Connext DDS;14/05/2024 15:22;82;HIGH;;CWE-20;This vulnerability is a type of  'Improper Input Validation' because the FastDDS subscriber crashes due to not properly validating the 'RTPS' packet received from the publisher. This lack of validation allows a malformed packet to cause a crash.;Vulners
OSV:CVE-2024-30258;CVE-2024-30258;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS` packet, the subscriber crashes when creating `pthread`. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-20;The vulnerability stems from improper input validation of the 'RTPS' packet, allowing for a specially crafted packet to crash the subscriber process during thread creation. This falls under CWE-20, which broadly covers improper input validation.;Vulners
NVD:CVE-2024-30258;CVE-2024-30258;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS` packet, the subscriber crashes when creating `pthread`. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-120;This vulnerability is a classic example of a buffer overflow, where a malformed packet can cause data to be written outside of the intended buffer, leading to a crash. ;Vulners
OSV:CVE-2024-30259;CVE-2024-30259;FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet, heap buffer overflow occurs on the subscriber. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.;Fast DDS;14/05/2024 15:22;82;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when the code writing to a heap buffer overruns the buffer's boundary, potentially overwriting adjacent data or executing arbitrary code.;Vulners
UB:CVE-2024-30259;CVE-2024-30259;"FastDDS is a C++ implementation of the DDS (Data Distribution Service)
standard of the OMG (Object Management Group). Prior to versions 2.14.1,
2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet,
heap buffer overflow occurs on the subscriber. This can remotely crash any
Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1,
2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.";Fast DDS;14/05/2024 00:00;82;HIGH;;CWE-122;Heap-based buffer overflow occurs when the code writes outside the allocated memory on the heap. This vulnerability allows attackers to overwrite critical data or execute arbitrary code, potentially leading to a crash (DoS) or remote code execution.;Vulners
UB:CVE-2024-30258;CVE-2024-30258;"FastDDS is a C++ implementation of the DDS (Data Distribution Service)
standard of the OMG (Object Management Group). Prior to versions 2.14.1,
2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS`
packet, the subscriber crashes when creating `pthread`. This can remotely
crash any Fast-DDS process, potentially leading to a DOS attack. Versions
2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.";Fast DDS;14/05/2024 00:00;82;HIGH;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs because the software copies attacker-controlled data into a fixed-size buffer without verifying that the data fits within the buffer boundaries. In this case, the malformed RTPS packet acts as the attacker-controlled data leading to the crash during pthread creation.;Vulners
VULNRICHMENT:CVE-2024-30259;CVE-2024-30259 FastDDS heap buffer overflow when publisher sends malformed packet;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet, heap buffer overflow occurs on the subscriber. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;13/05/2024 14:45;82;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs as the software writes data past the allocated buffer size on the heap, potentially allowing an attacker to overwrite critical data or execute arbitrary code.;Vulners
CVELIST:CVE-2024-30259;CVE-2024-30259 FastDDS heap buffer overflow when publisher sends malformed packet;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves malformed `RTPS` packet, heap buffer overflow occurs on the subscriber. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;13/05/2024 14:45;82;HIGH;;CWE-120;This vulnerability is classified as CWE-120, 'Buffer Copy without Checking Size of Input Data,'  because the subscriber process in FastDDS doesn't properly check the size of incoming 'RTPS' packets before writing them to memory. This allows a malicious actor to send oversized or malformed packets that overflow the allocated buffer, leading to a crash.;Vulners
VULNRICHMENT:CVE-2024-30258;CVE-2024-30258 FastDDS crash when publisher send malformed packet;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS` packet, the subscriber crashes when creating `pthread`. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;13/05/2024 14:41;82;HIGH;;CWE-20;This vulnerability falls under CWE-20, Improper Input Validation. The vulnerability occurs because FastDDS fails to properly validate a malformed RTPS packet from a publisher, leading to a crash during thread creation in the subscriber.;Vulners
CVELIST:CVE-2024-30258;CVE-2024-30258 FastDDS crash when publisher send malformed packet;"FastDDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). Prior to versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8, when a publisher serves a malformed `RTPS` packet, the subscriber crashes when creating `pthread`. This can remotely crash any Fast-DDS process, potentially leading to a DOS attack. Versions 2.14.1, 2.13.5, 2.10.4, and 2.6.8 contain a patch for the issue.
";Fast DDS;13/05/2024 14:41;82;HIGH;;CWE-404;This vulnerability falls under CWE-404: Improper Resource Shutdown or Release. The FastDDS subscriber crashes while trying to create a pthread due to a malformed packet, indicating an inability to gracefully handle the invalid input and properly manage resources (pthread in this case).;Vulners
CVE-2024-30916;CVE-2024-30916;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted max_samples parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 06:15;0;NONE;;CWE-400;This vulnerability aligns with CWE-400: Uncontrolled Resource Consumption.  By manipulating the 'max_samples' parameter, an attacker can force the DurabilityService component to consume excessive resources, leading to a denial of service.  The mention of obtaining sensitive information suggests potential memory leakage as a side effect.;Vulners
NVD:CVE-2024-30916;CVE-2024-30916;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted max_samples parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 06:15;0;NONE;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description states a local attacker can manipulate the 'max_samples' parameter to cause a denial of service, indicating excessive resource use leading to service disruption. Additionally, the attacker can obtain sensitive information, suggesting a possible leak or exposure due to mishandled resources.;Vulners
CVE-2024-30917;CVE-2024-30917;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted history_depth parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 06:15;55;MEDIUM;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input, 'Classic Buffer Overflow') occurs as the vulnerability allows an attacker to specify a crafted 'history_depth' parameter exceeding the buffer capacity, leading to potential buffer overflow. This could crash the service (DoS) and might leak sensitive memory information.;Vulners
NVD:CVE-2024-30917;CVE-2024-30917;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted history_depth parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 06:15;55;MEDIUM;;CWE-120;This vulnerability involves a buffer overflow, as indicated by the potential for denial of service and information disclosure caused by a crafted 'history_depth' parameter. An attacker could send excessively large values for this parameter, potentially overwriting critical memory and disrupting service or leaking data.;Vulners
VULNRICHMENT:CVE-2024-30917;CVE-2024-30917;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted history_depth parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 00:00;0;NONE;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when data is written to a buffer without proper bounds checking, potentially overwriting adjacent memory. In this case, the 'history_depth' parameter is not properly validated, allowing an attacker to manipulate it and potentially overflow a buffer, causing a denial of service or information disclosure.;Vulners
CVELIST:CVE-2024-30916;CVE-2024-30916;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted max_samples parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 00:00;0;NONE;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description highlights that a crafted 'max_samples' parameter can lead to denial of service (DoS), implying excessive resource usage by the application.;Vulners
UB:CVE-2024-30917;CVE-2024-30917;"An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a
local attacker to cause a denial of service (DoS) and obtain sensitive
information via a crafted history_depth parameter in DurabilityService QoS
component.";Fast DDS;11/04/2024 00:00;0;NONE;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')) occurs as the vulnerability allows an attacker to cause a denial of service and potentially obtain sensitive information by providing a crafted 'history_depth' parameter, which suggests a possible buffer overflow scenario.;Vulners
CVELIST:CVE-2024-30917;CVE-2024-30917;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted history_depth parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 00:00;0;NONE;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input) describes vulnerabilities that occur when data is copied from an input buffer to an output buffer without verifying that the input data fits within the boundaries of the output buffer. In this case, the crafted 'history_depth' parameter likely triggers an excessive memory allocation or processing, leading to DoS and potential information disclosure.;Vulners
VULNRICHMENT:CVE-2024-30916;CVE-2024-30916;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted max_samples parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 00:00;0;NONE;;CWE-400;This vulnerability likely falls under CWE-400: Uncontrolled Resource Consumption, as it involves a crafted parameter ('max_samples') causing a denial of service. This indicates excessive resource consumption.;Vulners
UB:CVE-2024-30916;CVE-2024-30916;"An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a
local attacker to cause a denial of service (DoS) and obtain sensitive
information via a crafted max_samples parameter in DurabilityService QoS
component.";Fast DDS;11/04/2024 00:00;0;NONE;;CWE-400;CWE-400 (Uncontrolled Resource Consumption) refers to the vulnerability where an attacker can consume more resources than intended, leading to a denial of service.  In this case, crafting the 'max_samples' parameter allows excessive resource usage.;Vulners
NVD:CVE-2024-28231;CVE-2024-28231;Prior to versions 2.14.0, 2.13.4, 2.12.3, 2.10.4, and 2.6.8, manipulated DATA Submessage can cause a heap overflow error in the Fast-DDS process, causing the process to be terminated remotely. Additionally, the payload_size in the DATA Submessage packet is declared as uint32_t...;Fast DDS;20/03/2024 20:15;96;CRITICAL;;CWE-122;This vulnerability is a classic heap overflow, occurring when the 'payload_size' isn't properly validated and allows more data to be written to the heap than allocated, leading to potential code execution.;Vulners
CVE-2024-28231;CVE-2024-28231;Prior to versions 2.14.0, 2.13.4, 2.12.3, 2.10.4, and 2.6.8, manipulated DATA Submessage can cause a heap overflow error in the Fast-DDS process, causing the process to be terminated remotely. Additionally, the payload_size in the DATA Submessage packet is declared as uint32_t...;Fast DDS;20/03/2024 20:15;96;CRITICAL;;CWE-122;This vulnerability describes a heap overflow situation which falls under CWE-122: Heap-based Buffer Overflow. The description mentions a manipulated DATA Submessage leading to a heap overflow in the Fast-DDS process. This means the application is writing data beyond the allocated memory space in the heap, potentially leading to crashes or remote code execution.;Vulners
VULNRICHMENT:CVE-2024-28231;CVE-2024-28231 Manipulated DATA Submessage causes a heap-buffer-overflow error;Prior to versions 2.14.0, 2.13.4, 2.12.3, 2.10.4, and 2.6.8, manipulated DATA Submessage can cause a heap overflow error in the Fast-DDS process, causing the process to be terminated remotely. Additionally, the payload_size in the DATA Submessage packet is declared as uint32_t...;Fast DDS;20/03/2024 20:03;96;CRITICAL;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs as the vulnerability allows a manipulated DATA Submessage to write past the allocated memory on the heap, leading to potential code execution or denial of service.;Vulners
CVELIST:CVE-2024-28231;CVE-2024-28231 Manipulated DATA Submessage causes a heap-buffer-overflow error;Prior to versions 2.14.0, 2.13.4, 2.12.3, 2.10.4, and 2.6.8, manipulated DATA Submessage can cause a heap overflow error in the Fast-DDS process, causing the process to be terminated remotely. Additionally, the payload_size in the DATA Submessage packet is declared as uint32_t...;Fast DDS;20/03/2024 20:03;96;CRITICAL;;CWE-787;The vulnerability allows an attacker to send a manipulated DATA Submessage with a crafted 'payload_size', exceeding the allocated heap memory and causing a heap overflow. This could potentially allow for remote code execution.;Vulners
UB:CVE-2024-28231;CVE-2024-28231;"Prior to versions 2.14.0, 2.13.4,
2.12.3, 2.10.4, and 2.6.8, manipulated DATA Submessage can cause a heap
overflow error in the Fast-DDS process, causing the process to be
terminated remotely. Additionally, the payload_size in the DATA Submessage
packet is declared as uint32_t...";Fast DDS;20/03/2024 00:00;96;CRITICAL;;CWE-122;This vulnerability relates to a heap overflow that can be triggered remotely. CWE-122 (Heap-Based Buffer Overflow) occurs when the code writes outside the allocated memory space of a heap buffer. ;Vulners
CVE-2024-26369;CVE-2024-26369;An issue in the HistoryQosPolicy component of FastDDS v2.12.x, v2.11.x, v2.10.x, and v2.6.x leads to a SIGABRT (signal abort) upon receiving DataWriter's data.;Fast DDS;19/03/2024 06:15;75;HIGH;;CWE-674;This vulnerability likely falls under CWE-674: Uncontrolled Recursion. The description mentions a 'SIGABRT' upon receiving data, which often indicates a crash due to excessive function calls, potentially caused by recursion without a proper base case.;Vulners
NVD:CVE-2024-26369;CVE-2024-26369;An issue in the HistoryQosPolicy component of FastDDS v2.12.x, v2.11.x, v2.10.x, and v2.6.x leads to a SIGABRT (signal abort) upon receiving DataWriter's data.;Fast DDS;19/03/2024 06:15;75;HIGH;;CWE-400;The issue describes a denial of service (specifically a SIGABRT crash) triggered by receiving data, indicating a resource management problem. CWE-400 (Uncontrolled Resource Consumption) broadly covers such scenarios where resource usage is not properly managed, leading to exhaustion.;Vulners
VULNRICHMENT:CVE-2024-26369;CVE-2024-26369;An issue in the HistoryQosPolicy component of FastDDS v2.12.x, v2.11.x, v2.10.x, and v2.6.x leads to a SIGABRT (signal abort) upon receiving DataWriter's data.;Fast DDS;19/03/2024 00:00;0;NONE;;CWE-120;This vulnerability likely falls under CWE-120 (Classic Buffer Overflow) or a related CWE within the 'Buffer Errors' category. The description mentions a SIGABRT occurring when receiving data, which strongly suggests a memory access error, potentially a buffer overflow. Without more details, it's impossible to pinpoint the exact CWE.;Vulners
UB:CVE-2024-26369;CVE-2024-26369;"An issue in the HistoryQosPolicy component of FastDDS v2.12.x, v2.11.x,
v2.10.x, and v2.6.x leads to a SIGABRT (signal abort) upon receiving
DataWriter's data.";Fast DDS;19/03/2024 00:00;0;NONE;;CWE-400;This issue indicates a potential Uncontrolled Resource Consumption ('Resource Exhaustion') because the SIGABRT signal suggests an abnormal program termination likely due to the software's inability to handle the incoming data from the DataWriter. This could point to insufficient memory allocation or other resource management problems triggered by specific data inputs, ultimately leading to a denial of service.;Vulners
CVE-2023-50716;CVE-2023-50716;Prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7, an invalid DATA_FRAG Submessage causes a bad-free error, and the Fast-DDS process can be remotely terminated. If an invalid Data_Frag packet is sent, the `Inline_qos, SerializedPayload` member of object `ch` will attempt to release memory without initialization, resulting in a 'bad-free' error...;Fast DDS;06/03/2024 18:15;96;CRITICAL;;CWE-416;The vulnerability description describes a 'bad-free' error, which falls under the category of Use After Free vulnerabilities. This happens because the code attempts to free memory ('Inline_qos, SerializedPayload' member) that was not properly initialized, leading to potential memory corruption or crashes.;Vulners
DEBIANCVE:CVE-2023-50716;CVE-2023-50716;Prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7, an invalid DATA_FRAG Submessage causes a bad-free error, and the Fast-DDS process can be remotely terminated. If an invalid Data_Frag packet is sent, the `Inline_qos, SerializedPayload` member of object `ch` will attempt to release memory without initialization, resulting in a 'bad-free' error...;Fast DDS;06/03/2024 18:15;96;CRITICAL;;CWE-416;This vulnerability involves a 'bad free' error, meaning a program is attempting to free memory that was not properly allocated or has already been freed. This falls under the category of 'Use After Free', where a resource (in this case, memory) is used after it has been released.;Vulners
PRION:CVE-2023-50716;Memory corruption;Prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7, an invalid DATA_FRAG Submessage causes a bad-free error, and the Fast-DDS process can be remotely terminated. If an invalid Data_Frag packet is sent, the `Inline_qos, SerializedPayload` member of object `ch` will attempt to release memory without initialization, resulting in a 'bad-free' error...;Fast DDS;06/03/2024 18:15;58;;;CWE-416: Use After Free;The vulnerability occurs because the code attempts to free memory using an uninitialized pointer ('Inline_qos, SerializedPayload' member) when an invalid DATA_FRAG packet is received. This is a classic example of a use-after-free vulnerability, where the program tries to access memory after it has been freed.;Vulners
VULNRICHMENT:CVE-2023-50716;CVE-2023-50716 Invalid DATA_FRAG Submessage causes a bad-free error;Prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7, an invalid DATA_FRAG Submessage causes a bad-free error, and the Fast-DDS process can be remotely terminated. If an invalid Data_Frag packet is sent, the `Inline_qos, SerializedPayload` member of object `ch` will attempt to release memory without initialization, resulting in a 'bad-free' error...;Fast DDS;06/03/2024 17:23;96;CRITICAL;;CWE-416: Use After Free;The vulnerability occurs because the software attempts to release (free) memory that has not been initialized properly, leading to a 'bad-free' condition.  This can allow an attacker to potentially execute arbitrary code.;Vulners
CVELIST:CVE-2023-50716;CVE-2023-50716 Invalid DATA_FRAG Submessage causes a bad-free error;Prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7, an invalid DATA_FRAG Submessage causes a bad-free error, and the Fast-DDS process can be remotely terminated. If an invalid Data_Frag packet is sent, the `Inline_qos, SerializedPayload` member of object `ch` will attempt to release memory without initialization, resulting in a 'bad-free' error...;Fast DDS;06/03/2024 17:23;96;CRITICAL;;CWE-416: Use After Free;The vulnerability occurs because the code attempts to release memory ('free') that was not properly initialized. This is a type of 'use after free' vulnerability where a resource is accessed after it has been freed, leading to potential crashes or code execution.;Vulners
UB:CVE-2023-50716;CVE-2023-50716;"Prior to
versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7, an invalid DATA_FRAG
Submessage causes a bad-free error, and the Fast-DDS process can be
remotely terminated. If an invalid Data_Frag packet is sent, the
`Inline_qos, SerializedPayload` member of object `ch` will attempt to
release memory without initialization, resulting in a 'bad-free' error.
Versions 2.13.0, 2.12.2, 2.11.3, 2.10.2, and 2.6.7 fix this issue....";Fast DDS;06/03/2024 00:00;96;CRITICAL;;CWE-416;This vulnerability involves a 'use-after-free' scenario where memory allocated for handling the 'DATA_FRAG' submessage is prematurely freed due to an invalid packet. Later attempts to access or release this freed memory (specifically 'Inline_qos, SerializedPayload' member) lead to a 'bad-free' error, potentially crashing the Fast-DDS process.;Vulners
CVE-2023-50257;CVE-2023-50257;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 20:15;96;CRITICAL;;CWE-311;This issue stems from a lack of encryption for sensitive information, specifically the 'p[UD]' data and 'guid' values used in the disconnection process.  This aligns with CWE-311, which deals with Missing Encryption of Sensitive Data.;Vulners
DEBIANCVE:CVE-2023-50257;CVE-2023-50257;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 20:15;96;CRITICAL;;CWE-311;This vulnerability stems from a lack of encryption for sensitive data, specifically the 'p[UD]' and 'guid' values used for node disconnections. This absence of encryption allows an attacker to intercept and manipulate these values, leading to unauthorized disconnections.;Vulners
OSV:CVE-2023-50257;CVE-2023-50257;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 20:15;96;CRITICAL;;CWE-311;This vulnerability stems from a lack of encryption for sensitive data (`p[UD]` and `guid`) during the node disconnection process. This makes it possible for an attacker to intercept and manipulate this data, leading to unauthorized disconnections and denial of service. ;Vulners
NVD:CVE-2023-50257;CVE-2023-50257;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 20:15;96;CRITICAL;;CWE-311;This vulnerability stems from a lack of encryption for sensitive data, specifically the 'p[UD]' and 'guid' values used in the disconnection process. This missing encryption could allow an attacker to intercept and manipulate these values, leading to unauthorized disconnections.;Vulners
PRION:CVE-2023-50257;Design/Logic Flaw;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 20:15;58;;;CWE-311;This vulnerability describes a lack of encryption for sensitive data, specifically the data and GUID values used for node disconnection.  This falls under CWE-311: Missing Encryption of Sensitive Data, which makes the data susceptible to eavesdropping and replay attacks.;Vulners
CVELIST:CVE-2023-50257;CVE-2023-50257 Disconnect Vulnerability in RTPS Packets Used by SROS2;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 19:22;96;CRITICAL;;CWE-311;This vulnerability relates to CWE-311: Missing Encryption of Sensitive Data, as the data (`p[UD]`) and `guid` values used for managing connections are not encrypted, allowing an attacker to intercept and manipulate them.;Vulners
VULNRICHMENT:CVE-2023-50257;CVE-2023-50257 Disconnect Vulnerability in RTPS Packets Used by SROS2;Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected...;Fast DDS;19/02/2024 19:22;96;CRITICAL;;CWE-311;This vulnerability describes a lack of encryption for sensitive data, specifically the data ('p[UD]') and 'guid' values used for node disconnection. This falls under CWE-311: Missing Encryption of Sensitive Data, as it allows an attacker to intercept and potentially manipulate these values to disrupt communication.;Vulners
DEBIAN_DSA-5568.NASL;Debian DSA-5568-1 : fastdds - security update;"The remote Debian 12 host has packages installed that are affected by a vulnerability as referenced in the dsa-5568 advisory.

  - Fast DDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object     Management Group). The call to free() could     potentially leave the pointer in the attackers control which could lead to a double free...";Fast DDS;27/11/2023 00:00;86;HIGH;;CWE-416;The product's use of a pointer after it has been freed can allow an attacker to execute arbitrary code or cause a denial of service.;Vulners
NVD:CVE-2023-42459;CVE-2023-42459;The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...;Fast DDS;16/10/2023 21:15;75;HIGH;;CWE-415;CWE-415 (Double Free) occurs when a program attempts to free a memory location that has already been freed, potentially leading to memory corruption, crashes, or arbitrary code execution.;Vulners
CVE-2023-42459;CVE-2023-42459;The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...;Fast DDS;16/10/2023 21:15;86;HIGH;;CWE-416;This vulnerability falls under CWE-416: Use After Free. While the description mentions 'double free', the core issue is that the pointer is left accessible after being freed, allowing for potential use-after-free exploits by manipulating the freed memory.;Vulners
DEBIANCVE:CVE-2023-42459;CVE-2023-42459;The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...;Fast DDS;16/10/2023 21:15;86;HIGH;;CWE-416;The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.;Vulners
OSV:CVE-2023-42459;CVE-2023-42459;The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...;Fast DDS;16/10/2023 21:15;86;HIGH;;CWE-416: Use After Free;The code attempts to free() memory that might still be accessible or controlled by an attacker after the free() operation. This could allow the attacker to manipulate the program's behavior, potentially leading to a double-free scenario.;Vulners
PRION:CVE-2023-42459;Double free;The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...;Fast DDS;16/10/2023 21:15;50;;;CWE-416;This vulnerability describes a 'Use After Free' scenario where a pointer, after being freed, is left in a state where an attacker might still control it. This could allow the attacker to potentially trigger a double free vulnerability by calling free() on the same memory location twice.;Vulners
CVELIST:CVE-2023-42459;CVE-2023-42459 Malformed DATA submessage leads to bad-free error in Fast-DDS;The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...;Fast DDS;16/10/2023 20:56;86;HIGH;;CWE-415;CWE-415 (Double Free) occurs when a program attempts to free dynamically allocated memory twice, which can corrupt the heap memory structure and lead to potential code execution.;Vulners
UB:CVE-2023-42459;CVE-2023-42459;"The
call to free() could potentially leave the pointer in the attackers control
which could lead to a double free. This issue has been addressed in
versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7...";Fast DDS;16/10/2023 00:00;86;HIGH;;CWE-416;This vulnerability relates to a potential 'Use After Free' scenario, where a call to free() might not completely remove the pointer from the attacker's control, allowing them to potentially free the same memory location twice and lead to unexpected program behavior.;Vulners
OSV:USN-6306-1;fastdds vulnerabilities;"It was discovered that Fast DDS incorrectly handled certain inputs.
A remote attacker could possibly use this issue to cause a denial of
service and information exposure. This issue only affected Ubuntu
22.04 LTS. (CVE-2021-38425)

It was discovered that Fast DDS incorrectly handled certain inputs.
An attacker could possibly use this issue to cause a crash.
(CVE-2023-39534, CVE-2023-39945, CVE-2023-39946, CVE-2023-39947,
CVE-2023-39948, CVE-2023-39949)
";Fast DDS;24/08/2023 17:34;91;CRITICAL;;CWE-20;This vulnerability stems from improper input validation, allowing attackers to send specially crafted inputs that the system doesn't handle correctly, leading to denial of service, information exposure, or crashes.;Vulners
UBUNTU_USN-6306-1.NASL;Ubuntu 22.04 ESM / 23.04 : Fast DDS vulnerabilities (USN-6306-1);"The remote Ubuntu 22.04 ESM host has packages installed that are affected by multiple vulnerabilities as referenced in the USN-6306-1 advisory.

  - eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a     specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-     service condition and information exposure. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger     assertion failure, crashing FastDDS...";Fast DDS;24/08/2023 00:00;91;CRITICAL;;CWE-400;This vulnerability involves uncontrolled resource consumption (specifically network bandwidth) due to the processing of a specially crafted packet, leading to a denial of service. Additionally, the mention of 'information exposure' suggests potential unauthorized access to data, aligning with the broader implications of CWE-400.;Vulners
USN-6306-1;Fast DDS vulnerabilities;"## Releases

  * Ubuntu 23.04 
  * Ubuntu 22.04 LTS

## Packages

  * fastdds \- eProsima FastDDS Discovery Server and Tools

## Details

It was discovered that Fast DDS incorrectly handled certain inputs.  
A remote attacker could possibly use this issue to cause a denial of  
service and information exposure...";Fast DDS;24/08/2023 00:00;91;CRITICAL;;CWE-405: Information Exposure Through Query Results;The description mentions 'information exposure' implying that the vulnerability might allow an attacker to extract sensitive information from the application by manipulating certain inputs that are not properly handled by Fast DDS.;Vulners
DEBIAN_DSA-5481.NASL;Debian DSA-5481-1 : fastdds - security update;"The remote Debian 11 / 12 host has packages installed that are affected by multiple vulnerabilities as referenced in the dsa-5481 advisory.

  - eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object     Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger     assertion failure, crashing FastDDS...";Fast DDS;22/08/2023 00:00;82;HIGH;;CWE-617;This vulnerability involves improper handling of assertions, which can allow an attacker to potentially crash the application (Fast DDS) by triggering an assertion failure.;Vulners
DEBIAN:DSA-5481-1:1B39B;[SECURITY] [DSA 5481-1] fastdds security update;"- -------------------------------------------------------------------------
Debian Security Advisory DSA-5481-1                   security@debian.org
https://www.debian.org/security/                       Moritz Muehlenhoff
August 20, 2023                       https://www.debian.org/security/faq
- -------------------------------------------------------------------------

Package        : fastdds
CVE ID         : CVE-2023-39534 CVE-2023-39945 CVE-2023-39946 CVE-2023-39947 
                 CVE-2023-39948 CVE-2023-39949

Multipe security issues were discovered in Fast DDS, a C++ implementation
of the DDS (Data Distribution Service), which might result in denial of
service or potentially the execution of arbitrary code when processing
malformed RTPS packets.

For the oldstable distribution (bullseye), these problems have been fixed
in version 2.1.0+ds-9+deb11u1.

For the stable distribution (bookworm), these problems have been fixed in
version 2.9.1+ds-1+deb12u1.

We recommend that you upgrade your fastdds packages.

For the detailed security status of fastdds please refer to
its security tracker page at:
https://security-tracker.debian.org/tracker/fastdds

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: https://www.debian.org/security/

Mailing list: debian-security-announce@lists.debian.org...";Fast DDS;20/08/2023 17:44;82;HIGH;;CWE-119;CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) is a broad category that encompasses buffer overflows and other memory access issues.  The description mentions vulnerabilities leading to denial of service and potential code execution from malformed RTPS packets. This strongly suggests buffer overflow or similar memory corruption vulnerabilities.;Vulners
NVD:CVE-2023-39947;CVE-2023-39947;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed `PID_PROPERTY_LIST` parameters cause heap overflow at a different program counter. This can remotely crash any Fast-DDS process. Versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-122;This vulnerability involves a heap-based buffer overflow caused by improper handling of the 'PID_PROPERTY_LIST' parameter. An attacker can manipulate this parameter to send data exceeding the allocated buffer size, potentially overwriting critical memory and leading to remote code execution.;Vulners
NVD:CVE-2023-39949;CVE-2023-39949;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-682;This vulnerability relates to improper validation of sequence numbers, which falls under the category of 'Incorrect Calculation' as per CWE-682. An attacker could manipulate these sequence numbers to cause an assertion failure, leading to a denial of service.;Vulners
CVE-2023-39534;CVE-2023-39534;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-617;This vulnerability involves an assertion failure, indicating a failure to properly handle an exceptional or unexpected condition during program execution. This often leads to crashes, making it a denial-of-service vulnerability.;Vulners
CVE-2023-39945;CVE-2023-39945;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5, a data submessage sent to PDP port raises unhandled `BadParamException` in fastcdr, which in turn crashes fastdds. Versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;82;HIGH;;CWE-20;This vulnerability stems from improper input validation. The software fails to sanitize data received on the PDP port, leading to an unhandled exception when processing a specific type of submessage.  This lack of validation allows malformed data to cause unexpected behavior, culminating in a crash.;Vulners
CVE-2023-39946;CVE-2023-39946;Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST parameter that contains a CDR string with length larger than the size of actual content. In `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`, `memcpy` is called to first copy the octet'ized length and then to copy the data into `properties_.data`...;Fast DDS;11/08/2023 14:15;82;HIGH;;CWE-122;The product copies C strings, without checking the size of the source buffer, potentially leading to a buffer overflow. In this case, a crafted PID_PROPERTY_LIST parameter with a larger CDR string length than the actual content leads to the overflow during the memcpy operation in the `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper` function.;Vulners
DEBIANCVE:CVE-2023-39534;CVE-2023-39534;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-617;This vulnerability is a CWE-617: Reachable Assertion. The description states that a malformed GAP submessage can trigger an assertion failure, leading to a crash. This indicates that an assertion, intended for debugging and development, is reachable during runtime with crafted input, causing a denial of service.;Vulners
NVD:CVE-2023-39534;CVE-2023-39534;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-617;This vulnerability falls under CWE-617, which refers to Denial of Service (DoS) caused by an Assertion Failure. In this case, a malformed GAP submessage leads to an assertion failure within FastDDS, causing it to crash and resulting in a denial of service.;Vulners
CVE-2023-39949;CVE-2023-39949;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-20;CWE-20 (Improper Input Validation) refers to the failure to properly validate data received from an external source before using it. In this case, Fast DDS fails to validate sequence numbers, allowing an attacker to send a malformed sequence number that triggers an assertion failure and crashes the process.;Vulners
DEBIANCVE:CVE-2023-39946;CVE-2023-39946;Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST parameter that contains a CDR string with length larger than the size of actual content. In `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`, `memcpy` is called to first copy the octet'ized length and then to copy the data into `properties_.data`...;Fast DDS;11/08/2023 14:15;82;HIGH;;CWE-122;This vulnerability involves a heap-based buffer overflow due to copying data using `memcpy` without ensuring the destination buffer is large enough to hold the source data, potentially allowing for arbitrary code execution.;Vulners
OSV:CVE-2023-39949;CVE-2023-39949;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-682;CWE-682 (Incorrect Calculation) occurs when a software application performs a calculation that produces incorrect or unexpected results, potentially leading to vulnerabilities. In this case, improper validation of sequence numbers signifies an incorrect calculation that could be exploited for malicious purposes.;Vulners
CVE-2023-39947;CVE-2023-39947;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed `PID_PROPERTY_LIST` parameters cause heap overflow at a different program counter. This can remotely crash any Fast-DDS process. Versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;82;HIGH;;CWE-122;This vulnerability allows heap-based buffer overflows due to improper validation of the `PID_PROPERTY_LIST` parameter. This indicates a weakness in bounds checking, enabling data to overflow its allocated memory and potentially overwrite critical data or execute arbitrary code.;Vulners
DEBIANCVE:CVE-2023-39945;CVE-2023-39945;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5, a data submessage sent to PDP port raises unhandled `BadParamException` in fastcdr, which in turn crashes fastdds. Versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;82;HIGH;;CWE-20;This vulnerability falls under CWE-20, 'Improper Input Validation'.  The vulnerability occurs because eProsima Fast DDS doesn't properly validate data submessages received on the PDP port, leading to an unhandled exception.;Vulners
OSV:CVE-2023-39948;CVE-2023-39948;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.
";Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-248;This vulnerability falls under CWE-248: Uncaught Exception. The description states that a 'BadParamException' is not caught, leading to a potential crash. This indicates a lack of exception handling, which is a direct match for CWE-248.;Vulners
DEBIANCVE:CVE-2023-39949;CVE-2023-39949;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-682;This vulnerability arises due to improper validation of sequence numbers, which falls under the category of 'Incorrect Calculation'.  Attackers can exploit this by sending crafted sequence numbers, leading to unexpected behavior like assertion failures and crashes.;Vulners
NVD:CVE-2023-39946;CVE-2023-39946;Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST parameter that contains a CDR string with length larger than the size of actual content. In `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`, `memcpy` is called to first copy the octet'ized length and then to copy the data into `properties_.data`...;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-1290;This vulnerability is a classic example of a heap-based buffer overflow. The code fails to properly validate the length of data provided in the `PID_PROPERTY_LIST` parameter's CDR string. As a result, when `memcpy` is used to copy this data, it can write beyond the allocated buffer in the heap, leading to potential data corruption, crashes, or even arbitrary code execution.;Vulners
NVD:CVE-2023-39948;CVE-2023-39948;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.
";Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-476;This vulnerability relates to CWE-476: NULL Pointer Dereference, as it involves a failure to catch an exception (`BadParamException`) that likely arises from invalid or missing parameters, potentially leading to the use of a null pointer and a crash.;Vulners
OSV:CVE-2023-39534;CVE-2023-39534;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-617;This vulnerability relates to denial of service caused by an assertion failure, indicating a programmer error that is triggered by unexpected input (the malformed GAP submessage).;Vulners
CVE-2023-39948;CVE-2023-39948;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.
";Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-248;This vulnerability arises from improper handling of an exception (`BadParamException`) in Fast DDS, potentially allowing an attacker to cause a denial-of-service (DoS) by remotely triggering a crash. This aligns with CWE-248, which deals with unchecked return values/exceptions, leading to program control flaws.;Vulners
DEBIANCVE:CVE-2023-39947;CVE-2023-39947;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed `PID_PROPERTY_LIST` parameters cause heap overflow at a different program counter. This can remotely crash any Fast-DDS process. Versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;82;HIGH;;CWE-122;This vulnerability is a classic heap-based buffer overflow, where accepting a malformed 'PID_PROPERTY_LIST' parameter without proper size checks allows an attacker to write beyond the allocated buffer on the heap. This can lead to corruption of program data and potential arbitrary code execution.;Vulners
DEBIANCVE:CVE-2023-39948;CVE-2023-39948;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;75;HIGH;;CWE-248;This vulnerability falls under CWE-248: Uncaught Exception. The description states that a specific exception ('BadParamException') thrown by a component (Fast CDR) is not handled within the Fast DDS system. This lack of exception handling can lead to a crash, making it a denial-of-service vulnerability.;Vulners
PRION:CVE-2023-39946;Heap overflow;Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST parameter that contains a CDR string with length larger than the size of actual content. In `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`, `memcpy` is called to first copy the octet'ized length and then to copy the data into `properties_.data`...;Fast DDS;11/08/2023 14:15;50;;;CWE-1024;This vulnerability involves a heap-based buffer overflow in the 'ParameterPropertyList_t::push_back_helper' function. By providing a crafted PID_PROPERTY_LIST parameter with a larger length value than the actual content, an attacker can trigger a memcpy that writes beyond the allocated buffer on the heap.;Vulners
PRION:CVE-2023-39948;Information disclosure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;50;;;CWE-754;This vulnerability falls under CWE-754, 'Critical Function Implemented With Low-Level Language'.  The issue arises because an uncaught exception in the Fast CDR component, which is likely implemented in C++ (a low-level language), can lead to a crash in the Fast DDS process. This highlights the risk of handling exceptions improperly in low-level languages, where they may not have the same safeguards as higher-level languages.;Vulners
PRION:CVE-2023-39945;Information disclosure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5, a data submessage sent to PDP port raises unhandled `BadParamException` in fastcdr, which in turn crashes fastdds. Versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;50;;;CWE-20;This vulnerability describes an instance of 'Improper Input Validation,' as the software does not properly validate the data submessage received on the PDP port, leading to an unhandled exception.;Vulners
PRION:CVE-2023-39949;Design/Logic Flaw;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;50;;;CWE-20;CWE-20 (Improper Input Validation) occurs when software does not validate or incorrectly validates input data, in this case, sequence numbers, before using it in a way that could disrupt service or lead to crashes.;Vulners
PRION:CVE-2023-39534;Information disclosure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;50;;;CWE-617;This vulnerability is a type of denial of service, specifically caused by an assertion failure. CWE-617 deals with situations where software fails to properly handle exceptions or errors during its execution, potentially leading to crashes or unexpected behavior.;Vulners
PRION:CVE-2023-39947;Design/Logic Flaw;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed `PID_PROPERTY_LIST` parameters cause heap overflow at a different program counter. This can remotely crash any Fast-DDS process. Versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.;Fast DDS;11/08/2023 14:15;50;;;CWE-122;This vulnerability relates to a heap-based buffer overflow. This occurs when data copied into a buffer, allocated in the heap memory, exceeds the buffer's capacity, potentially leading to arbitrary code execution.;Vulners
VULNRICHMENT:CVE-2023-39949;CVE-2023-39949 Improper validation of sequence numbers leading to remotely reachable assertion failure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 13:55;75;HIGH;;CWE-682;This vulnerability stems from improper validation of sequence numbers, which falls under 'Incorrect Calculation' as it involves a failure to properly process or validate numerical data. This could allow an attacker to send maliciously crafted sequence numbers, triggering an assertion failure and crashing the Fast DDS process.;Vulners
CVELIST:CVE-2023-39949;CVE-2023-39949 Improper validation of sequence numbers leading to remotely reachable assertion failure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 13:55;75;HIGH;;CWE-682;CWE-682: Incorrect Calculation. The software calculates a value that can be used to directly access memory or another resource, but it uses an incorrect formula or method, potentially leading to an out-of-bounds error.;Vulners
VULNRICHMENT:CVE-2023-39948;CVE-2023-39948 Uncaught fastcdr exception (Unexpected CDR type received) crashing fastdds;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.
";Fast DDS;11/08/2023 13:51;75;HIGH;;CWE-754;This vulnerability describes an instance where an exception, 'BadParamException', is thrown but not handled ('not caught').  Unhandled exceptions can lead to unexpected program termination (crash) and potentially allow remote code execution.;Vulners
CVELIST:CVE-2023-39948;CVE-2023-39948 Uncaught fastcdr exception (Unexpected CDR type received) crashing fastdds;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0 and 2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and 2.6.5 contain a patch for this issue.
";Fast DDS;11/08/2023 13:51;75;HIGH;;CWE-754;This vulnerability stems from improper exception handling where a 'BadParamException' in Fast CDR is not caught within Fast DDS. This lack of exception handling allows for potential denial-of-service attacks as an uncaught exception can lead to process termination.;Vulners
VULNRICHMENT:CVE-2023-39947;CVE-2023-39947 Another heap overflow in push_back_helper;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed `PID_PROPERTY_LIST` parameters cause heap overflow at a different program counter. This can remotely crash any Fast-DDS process. Versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.;Fast DDS;11/08/2023 13:43;82;HIGH;;CWE-122;This vulnerability involves a heap overflow, which occurs when data is written outside the allocated memory space on the heap.  This is often caused by improper bounds checking when handling data, such as the 'PID_PROPERTY_LIST' parameters in this case.;Vulners
CVELIST:CVE-2023-39947;CVE-2023-39947 Another heap overflow in push_back_helper;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed `PID_PROPERTY_LIST` parameters cause heap overflow at a different program counter. This can remotely crash any Fast-DDS process. Versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.;Fast DDS;11/08/2023 13:43;82;HIGH;;CWE-122;This vulnerability involves a heap overflow, meaning a program writes data beyond the allocated memory space of the heap. This is often due to mishandling the size of data being written, as indicated by the 'malformed parameters' causing the overflow.;Vulners
VULNRICHMENT:CVE-2023-39946;CVE-2023-39946 Heap overflow in push_back_helper due to a CDR message;Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST parameter that contains a CDR string with length larger than the size of actual content. In `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`, `memcpy` is called to first copy the octet'ized length and then to copy the data into `properties_.data`...;Fast DDS;11/08/2023 13:37;82;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when content intended for a heap-allocated buffer exceeds the buffer's allocated size, leading to potential overwrites of adjacent memory.;Vulners
CVELIST:CVE-2023-39946;CVE-2023-39946 Heap overflow in push_back_helper due to a CDR message;Prior to versions 2.11.1, 2.10.2, 2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST parameter that contains a CDR string with length larger than the size of actual content. In `eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`, `memcpy` is called to first copy the octet'ized length and then to copy the data into `properties_.data`...;Fast DDS;11/08/2023 13:37;82;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when content intended for a heap-allocated buffer exceeds the buffer's boundaries due to insufficient bounds checking, potentially leading to data corruption or code execution.;Vulners
CVELIST:CVE-2023-39945;CVE-2023-39945 Malformed serialized data in a data submessage leads to unhandled exception;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5, a data submessage sent to PDP port raises unhandled `BadParamException` in fastcdr, which in turn crashes fastdds. Versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 13:21;82;HIGH;;CWE-20;This vulnerability is a case of improper input validation. The software doesn't properly validate the data submessage received on the PDP port, leading to an unhandled exception and subsequent crash.;Vulners
VULNRICHMENT:CVE-2023-39945;CVE-2023-39945 Malformed serialized data in a data submessage leads to unhandled exception;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5, a data submessage sent to PDP port raises unhandled `BadParamException` in fastcdr, which in turn crashes fastdds. Versions 2.11.0, 2.10.2, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 13:21;82;HIGH;;CWE-20;This vulnerability falls under CWE-20, Improper Input Validation, as it describes an unhandled exception ('BadParamException') triggered by a specific type of input (data submessage to PDP port) which ultimately leads to a crash.;Vulners
CVELIST:CVE-2023-39534;CVE-2023-39534 Malformed GAP submessage triggers assertion failure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 13:12;75;HIGH;;CWE-617;CWE-617 (Reaches Assertion) occurs when the application assumes something about the state of the program that is not guaranteed to be true. In this case, the assertion failure in Fast DDS suggests an unmet assumption about the format of incoming GAP submessages.;Vulners
VULNRICHMENT:CVE-2023-39534;CVE-2023-39534 Malformed GAP submessage triggers assertion failure;eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2, and 2.6.5, a malformed GAP submessage can trigger assertion failure, crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this issue.;Fast DDS;11/08/2023 13:12;75;HIGH;;CWE-400;The vulnerability is a Denial of Service (DoS) caused by improper input validation of the GAP submessage, leading to an assertion failure and crashing the FastDDS application.;Vulners
UB:CVE-2023-39534;CVE-2023-39534;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service
standard of the Object Management Group. Prior to versions 2.10.0, 2.9.2,
and 2.6.5, a malformed GAP submessage can trigger assertion failure,
crashing FastDDS. Version 2.10.0, 2.9.2, and 2.6.5 contain a patch for this
issue.";Fast DDS;11/08/2023 00:00;75;HIGH;;CWE-617;This vulnerability falls under CWE-617, 'Reachable Assertion'. The description highlights that a specifically crafted input (malformed GAP submessage) can trigger an assertion failure within eprosima Fast DDS, causing a crash. This signifies that an internal assumption made by the software during its execution is not holding true, leading to the failure.;Vulners
UB:CVE-2023-39946;CVE-2023-39946;"Prior to versions 2.11.1, 2.10.2,
2.9.2, and 2.6.6, heap can be overflowed by providing a PID_PROPERTY_LIST
parameter that contains a CDR string with length larger than the size of
actual content. In
`eprosima::fastdds::dds::ParameterPropertyList_t::push_back_helper`,
`memcpy` is called to first copy the octet'ized length and then to copy the
data into `properties_.data`...";Fast DDS;11/08/2023 00:00;82;HIGH;;CWE-122;This vulnerability is a classic heap-based buffer overflow (CWE-122). The code attempts to copy data using `memcpy` without ensuring that the destination buffer (`properties_.data`) is large enough to hold the source data (from `PID_PROPERTY_LIST`). This can lead to overwriting adjacent memory on the heap.;Vulners
UB:CVE-2023-39947;CVE-2023-39947;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service
standard of the Object Management Group. Prior to versions 2.11.1, 2.10.2,
2.9.2, and 2.6.6, even after the fix at commit 3492270, malformed
`PID_PROPERTY_LIST` parameters cause heap overflow at a different program
counter. This can remotely crash any Fast-DDS process. Versions 2.11.1,
2.10.2, 2.9.2, and 2.6.6 contain a patch for this issue.

#### Bugs

  * <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1043548>
";Fast DDS;11/08/2023 00:00;82;HIGH;;CWE-122;This vulnerability involves a heap-based buffer overflow occurring due to improper handling of the `PID_PROPERTY_LIST` parameter.  An attacker can manipulate this parameter to send data exceeding the allocated buffer size, potentially overwriting critical memory areas and causing a crash.;Vulners
UB:CVE-2023-39948;CVE-2023-39948;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service
standard of the Object Management Group. Prior to versions 2.10.0 and
2.6.5, the `BadParamException` thrown by Fast CDR is not caught in Fast
DDS. This can remotely crash any Fast DDS process. Versions 2.10.0 and
2.6.5 contain a patch for this issue.";Fast DDS;11/08/2023 00:00;75;HIGH;;CWE-754;This vulnerability arises from improper exception handling, specifically the failure to catch a 'BadParamException' in the Fast DDS application. An attacker could potentially exploit this by sending malformed data, leading to the uncaught exception and subsequent crash of the Fast DDS process.;Vulners
UB:CVE-2023-39949;CVE-2023-39949;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service
standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5,
improper validation of sequence numbers may lead to remotely reachable
assertion failure. This can remotely crash any Fast-DDS process. Versions
2.9.1 and 2.6.5 contain a patch for this issue.";Fast DDS;11/08/2023 00:00;75;HIGH;;CWE-682;This vulnerability falls under CWE-682, 'Incorrect Calculation'. The description states that improper validation of sequence numbers is the root cause. This implies a flaw in how the software calculates or validates the sequence numbers, leading to the assertion failure.;Vulners
UB:CVE-2023-39945;CVE-2023-39945;"eprosima Fast DDS is a C++ implementation of the Data Distribution Service
standard of the Object Management Group. Prior to versions 2.11.0, 2.10.2,
2.9.2, and 2.6.5, a data submessage sent to PDP port raises unhandled
`BadParamException` in fastcdr, which in turn crashes fastdds. Versions
2.11.0, 2.10.2, 2.9.2, and 2.6.5 contain a patch for this issue.

#### Bugs

  * <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1043548>
";Fast DDS;11/08/2023 00:00;82;HIGH;;CWE-20;This vulnerability falls under CWE-20: Improper Input Validation. The software does not properly validate the data submessage received on the PDP port, leading to an unhandled exception and a crash.;Vulners
DEBIANCVE:CVE-2021-38425;CVE-2021-38425;eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-service condition and information exposure.;Fast DDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400, Uncontrolled Resource Consumption, because the attacker can send crafted packets that consume excessive resources (network bandwidth), leading to a denial of service.;Vulners
CVE-2021-38425;CVE-2021-38425;eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-service condition and information exposure.;Fast DDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400, Uncontrolled Resource Consumption, because the attacker can exploit the vulnerability to flood the target device, consuming its resources and potentially leading to a denial of service.;Vulners
OSV:CVE-2021-38425;CVE-2021-38425;eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-service condition and information exposure.;Fast DDS;05/05/2022 17:15;64;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption, as it involves flooding the target device with traffic, leading to a denial-of-service condition by exhausting available resources.;Vulners
NVD:CVE-2021-38425;CVE-2021-38425;eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-service condition and information exposure.;Fast DDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The vulnerability description mentions that an attacker can send specially crafted packets to flood the target device, indicating an uncontrolled use of resources like bandwidth, ultimately leading to a denial-of-service.;Vulners
PRION:CVE-2021-38425;Design/Logic Flaw;eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-service condition and information exposure.;Fast DDS;05/05/2022 17:15;64;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description states that a specially crafted packet can cause the software to consume excessive resources (flooding with traffic), leading to a denial of service.;Vulners
CVELIST:CVE-2021-38425;CVE-2021-38425 eProsima Fast DDS Network Amplification;eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to exploitation when an attacker sends a specially crafted packet to flood a target device with unwanted traffic, which may result in a denial-of-service condition and information exposure.;Fast DDS;05/05/2022 15:24;75;HIGH;;CWE-400;This vulnerability falls under CWE-400, Uncontrolled Resource Consumption. The description highlights that an attacker can send a crafted packet to flood the target, indicating an attack designed to exhaust resources and disrupt service, characteristic of resource consumption flaws.;Vulners
UB:CVE-2021-38425;CVE-2021-38425;"eProsima Fast DDS versions prior to 2.4.0 (#2269) are susceptible to
exploitation when an attacker sends a specially crafted packet to flood a
target device with unwanted traffic, which may result in a
denial-of-service condition and information exposure.";Fast DDS;05/05/2022 00:00;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description indicates that the vulnerability allows an attacker to flood the target device with traffic, indicating an inability to control resource usage and potentially leading to denial of service.;Vulners
OSV:CVE-2019-15137;CVE-2019-15137;The Access Control plugin in eProsima Fast RTPS through 1.9.0 allows fnmatch pattern matches with topic name strings (instead of the permission expressions themselves), which can lead to unintended connections between participants in a Data Distribution Service (DDS) network.;Fast DDS;18/08/2019 16:15;50;;;CWE-732: Incorrect Permission Assignment for Critical Resource;The vulnerability stems from using the topic name, a less restrictive input, for pattern matching instead of the permission expressions. This could allow unauthorized participants access to data streams due to overly broad matching, similar to granting excessive permissions.;Vulners
OSV:CVE-2019-15136;CVE-2019-15136;The Access Control plugin in eProsima Fast RTPS through 1.9.0 does not check partition permissions from remote participant connections, which can lead to policy bypass for a secure Data Distribution Service (DDS) partition.;Fast DDS;18/08/2019 16:15;50;;;CWE-285;CWE-285 (Improper Authorization) occurs because the software does not properly check permissions when a remote participant attempts to access a secure partition in eProsima Fast RTPS. This lack of authorization enforcement could allow unauthorized access to sensitive data.;Vulners
DEBIANCVE:CVE-2024-30916;CVE-2024-30916;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted max_samples parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 06:15;0;NONE;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description indicates that a crafted 'max_samples' parameter can lead to excessive resource use (DoS), indicating a lack of control over resource allocation.;Vulners
DEBIANCVE:CVE-2024-30917;CVE-2024-30917;An issue was discovered in eProsima FastDDS v.2.14.0 and before, allows a local attacker to cause a denial of service (DoS) and obtain sensitive information via a crafted history_depth parameter in DurabilityService QoS component.;Fast DDS;11/04/2024 06:15;55;MEDIUM;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input, 'Classic Buffer Overflow') occurs as the software doesn't validate the size of the 'history_depth' parameter before processing it. An attacker can exploit this by providing a crafted value that exceeds the buffer's capacity, potentially overwriting adjacent memory and causing a crash (DoS) or leaking sensitive information.;Vulners
DEBIANCVE:CVE-2024-26369;CVE-2024-26369;An issue in the HistoryQosPolicy component of FastDDS v2.12.x, v2.11.x, v2.10.x, and v2.6.x leads to a SIGABRT (signal abort) upon receiving DataWriter's data.;Fast DDS;19/03/2024 06:15;75;HIGH;;CWE-476;This vulnerability describes a NULL pointer dereference. Receiving DataWriter's data without proper handling in the HistoryQosPolicy component can cause the software to crash with a SIGABRT signal, which indicates an abnormal termination due to an internal error, likely due to accessing an invalid memory address (NULL pointer). ;Vulners
CVE-2021-38443;CVE-2021-38443;Eclipse CycloneDDS versions prior to 0.8.0 improperly handle invalid structures, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;98;CRITICAL;;CWE-129;This vulnerability falls under CWE-129: Improper Validation of Array Index, because the description mentions improper handling of 'invalid structures' within the XML parser, which strongly suggests a lack of proper bounds checking on array indices or similar data structures during parsing.  This could allow an attacker to write data outside of the allocated memory, leading to potential code execution.;Vulners
CVE-2021-38441;CVE-2021-38441;Eclipse CycloneDDS versions prior to 0.8.0 are vulnerable to a write-what-where condition, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;98;CRITICAL;;CWE-122;CWE-122 (Heap-Based Buffer Overflow) occurs when content intended for a buffer in memory exceeds the buffer's capacity and overwrites adjacent memory locations. In this case, the vulnerability in the XML parser of Eclipse CycloneDDS allows writing arbitrary data, indicating a potential buffer overflow scenario.;Vulners
NVD:CVE-2021-38441;CVE-2021-38441;Eclipse CycloneDDS versions prior to 0.8.0 are vulnerable to a write-what-where condition, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;98;CRITICAL;;CWE-787: Out-of-bounds Write;The vulnerability allows writing data past the intended buffer boundary in the XML parser, potentially overwriting critical data or executing arbitrary code.;Vulners
DEBIANCVE:CVE-2021-38443;CVE-2021-38443;Eclipse CycloneDDS versions prior to 0.8.0 improperly handle invalid structures, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;98;CRITICAL;;CWE-129;CWE-129 (Improper Validation of Array Index) occurs when the application does not validate the index value being used to access an array element. In this case, the CycloneDDS XML parser doesn't properly handle invalidly structured data, potentially allowing out-of-bounds memory access.;Vulners
DEBIANCVE:CVE-2021-38441;CVE-2021-38441;Eclipse CycloneDDS versions prior to 0.8.0 are vulnerable to a write-what-where condition, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;98;CRITICAL;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when data is written past the boundaries of a buffer allocated on the heap. In this case, the vulnerability in Eclipse CycloneDDS's XML parser allows writing arbitrary values, potentially leading to a heap overflow.;Vulners
NVD:CVE-2021-38443;CVE-2021-38443;Eclipse CycloneDDS versions prior to 0.8.0 improperly handle invalid structures, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;98;CRITICAL;;CWE-129;Improper handling of invalid structures, like the one in CycloneDDS's XML parser, often falls under CWE-129: Improper Validation of Array Index.  This means the software doesn't properly check if it's trying to access a valid memory location within the structure, potentially allowing an attacker to write data outside the intended bounds.;Vulners
PRION:CVE-2021-38441;Design/Logic Flaw;Eclipse CycloneDDS versions prior to 0.8.0 are vulnerable to a write-what-where condition, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;75;;;CWE-787: Out-of-bounds Write;The vulnerability allows writing data outside of the intended buffer in the XML parser, which is a classic example of a write-what-where condition leading to potential memory corruption.;Vulners
PRION:CVE-2021-38443;Code injection;Eclipse CycloneDDS versions prior to 0.8.0 improperly handle invalid structures, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 17:15;75;;;CWE-129: Improper Validation of Array Index;"The vulnerability description mentions improper handling of ""invalid structures"" within an XML parser, suggesting a potential for out-of-bounds write operations.  This aligns with CWE-129, which addresses vulnerabilities stemming from array index validation issues.";Vulners
CVELIST:CVE-2021-38443;CVE-2021-38443 Eclipse CycloneDDS Improper Handling of Syntactically Invalid Structure;Eclipse CycloneDDS versions prior to 0.8.0 improperly handle invalid structures, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 15:16;66;MEDIUM;;CWE-129;This vulnerability falls under CWE-129: Improper Validation of Array Index, which occurs because the software does not properly validate an array index value, allowing an attacker to write outside the bounds of the intended memory.;Vulners
CVELIST:CVE-2021-38441;CVE-2021-38441 Eclipse CycloneDDS Write-what-where Condition;Eclipse CycloneDDS versions prior to 0.8.0 are vulnerable to a write-what-where condition, which may allow an attacker to write arbitrary values in the XML parser.;CycloneDDS;05/05/2022 15:15;66;MEDIUM;;CWE-787: Out-of-bounds Write;A write-what-where condition often leads to an out-of-bounds write vulnerability, where data is written past the intended buffer boundaries due to improper input validation. In this case, the vulnerability in the XML parser allows an attacker to control what and where data is written.;Vulners
UB:CVE-2021-38443;CVE-2021-38443;"Eclipse CycloneDDS versions prior to 0.8.0 improperly handle invalid
structures, which may allow an attacker to write arbitrary values in the
XML parser.";CycloneDDS;05/05/2022 00:00;98;CRITICAL;;CWE-129;This vulnerability falls under CWE-129: Improper Validation of Array Index, as the description indicates improper handling of invalid structures, suggesting a possible array index or buffer overflow when parsing XML data.;Vulners
UB:CVE-2021-38441;CVE-2021-38441;"Eclipse CycloneDDS versions prior to 0.8.0 are vulnerable to a
write-what-where condition, which may allow an attacker to write arbitrary
values in the XML parser.";CycloneDDS;05/05/2022 00:00;98;CRITICAL;;CWE-787: Out-of-bounds Write;The vulnerability allows an attacker to write data past the intended buffer boundary in the XML parser, potentially overwriting critical data or executing arbitrary code.;Vulners
CVE-2020-18735;CVE-2020-18735;A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;75;HIGH;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when content intended for a heap-allocated buffer exceeds the buffer's boundaries and overwrites adjacent memory locations. In this case, the overflow exists in the /src/dds_stream.c file of the Eclipse IOT Cyclone DDS Project, potentially allowing attackers to cause a crash (denial of service) or execute arbitrary code.;Vulners
CVE-2020-18734;CVE-2020-18734;A stack buffer overflow in /ddsi/q_bitset.h of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;75;HIGH;;CWE-121;This vulnerability relates to a stack buffer overflow, a classic example of CWE-121. Data written to a buffer overflows the buffer's boundaries due to insufficient bounds checking, potentially overwriting adjacent memory on the stack. This can lead to a crash or, in worse scenarios, allow attackers to execute arbitrary code.;Vulners
NVD:CVE-2020-18734;CVE-2020-18734;A stack buffer overflow in /ddsi/q_bitset.h of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;75;HIGH;;CWE-121;CWE-121 (Stack-based Buffer Overflow) occurs when data written to a buffer on the stack exceeds the buffer's boundaries, overwriting adjacent memory locations. In this case, the overflow happens in the /ddsi/q_bitset.h file within the Eclipse IOT Cyclone DDS Project, potentially allowing an attacker to execute arbitrary code or cause a crash.;Vulners
OSV:CVE-2020-18735;CVE-2020-18735;A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;50;;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when the program writes past the allocated memory on the heap.  In this case, the overflow happens in the DDS subscriber server component of Eclipse IOT Cyclone DDS, potentially allowing for arbitrary code execution.;Vulners
OSV:CVE-2020-18734;CVE-2020-18734;A stack buffer overflow in /ddsi/q_bitset.h of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;50;;;CWE-121;CWE-121 (Stack-based Buffer Overflow) occurs when data written to a buffer on the stack exceeds the buffer's allocated space, potentially overwriting adjacent memory locations. This can lead to crashes or allow attackers to execute arbitrary code.;Vulners
NVD:CVE-2020-18735;CVE-2020-18735;A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;75;HIGH;;CWE-122;CWE-122: Heap-based Buffer Overflow. This occurs because the code writes outside the allocated memory space on the heap, which can lead to crashes or potentially allow malicious code execution.;Vulners
PRION:CVE-2020-18735;Heap overflow;A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;50;;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs when content intended for a section of memory allocated during runtime (the heap) overwrites the boundaries of that allocation, potentially overwriting critical data or allowing for arbitrary code execution.;Vulners
PRION:CVE-2020-18734;Stack overflow;A stack buffer overflow in /ddsi/q_bitset.h of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 21:15;50;;;CWE-121;CWE-121 (Stack-based Buffer Overflow) occurs when data written to a buffer on the stack exceeds the buffer's allocated space, potentially overwriting adjacent memory locations. In this case, the vulnerability in Eclipse IOT Cyclone DDS's q_bitset.h could allow an attacker to crash the DDS subscriber server or potentially execute arbitrary code.;Vulners
CVELIST:CVE-2020-18735;CVE-2020-18735;A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 20:07;0;NONE;;CWE-122;Heap-based buffer overflows occur when data written to a heap-allocated buffer exceeds the buffer's boundaries, potentially overwriting critical data structures and leading to crashes or code execution.;Vulners
CVELIST:CVE-2020-18734;CVE-2020-18734;A stack buffer overflow in /ddsi/q_bitset.h of Eclipse IOT Cyclone DDS Project v0.1.0 causes the DDS subscriber server to crash.;CycloneDDS;23/08/2021 20:07;0;NONE;;CWE-121;CWE-121 (Stack-based Buffer Overflow) occurs when data written to a buffer on the stack exceeds the buffer's allocated memory, potentially overwriting adjacent data and allowing for arbitrary code execution.;Vulners
UB:CVE-2020-18734;CVE-2020-18734;"A stack buffer overflow in /ddsi/q_bitset.h of Eclipse IOT Cyclone DDS
Project v0.1.0 causes the DDS subscriber server to crash.";CycloneDDS;23/08/2021 00:00;75;HIGH;;CWE-121;This vulnerability involves a stack buffer overflow, meaning data is written past the allocated space in memory. CWE-121, 'Stack-Based Buffer Overflow', aligns with this situation, as it occurs when a program writes more data to a buffer on the stack than what is allocated for that buffer.;Vulners
UB:CVE-2020-18735;CVE-2020-18735;"A heap buffer overflow in /src/dds_stream.c of Eclipse IOT Cyclone DDS
Project v0.1.0 causes the DDS subscriber server to crash.";CycloneDDS;23/08/2021 00:00;75;HIGH;;CWE-122;CWE-122 (Heap-Based Buffer Overflow) occurs when the code writes past the allocated memory on the heap, which can lead to crashes or potentially allow attackers to execute arbitrary code.;Vulners
NVD:CVE-2024-25724;CVE-2024-25724;"In RTI Connext Professional 5.3.1 through 6.1.0 before 6.1.1, a buffer overflow in XML parsing from Routing Service, Recording Service, Queuing Service, and Cloud Discovery Service allows attackers to execute code with the affected service's privileges, compromise the service's integrity, leak sensitive information, or crash the service. These attacks could be done via a remote malicious RTPS message; a compromised call with malicious parameters to the RTI_RoutingService_new, rti::recording::Service, RTI_QueuingService_new, or RTI_CDS_Service_new public APIs; or a compromised local file system containing a malicious XML file....";RTI Connext DDS;21/05/2024 19:15;73;HIGH;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when data written to a buffer exceeds the buffer's capacity, potentially overwriting adjacent memory locations. In this case, the vulnerability exists in the XML parsing functionality of several RTI Connext services, allowing attackers to send malicious input that could overflow a buffer.;Vulners
CVE-2024-25724;CVE-2024-25724;"In RTI Connext Professional 5.3.1 through 6.1.0 before 6.1.1, a buffer overflow in XML parsing from Routing Service, Recording Service, Queuing Service, and Cloud Discovery Service allows attackers to execute code with the affected service's privileges, compromise the service's integrity, leak sensitive information, or crash the service. These attacks could be done via a remote malicious RTPS message; a compromised call with malicious parameters to the RTI_RoutingService_new, rti::recording::Service, RTI_QueuingService_new, or RTI_CDS_Service_new public APIs; or a compromised local file system containing a malicious XML file....";RTI Connext DDS;21/05/2024 19:15;73;HIGH;;CWE-120;This vulnerability relates to a buffer overflow, which falls under CWE-120. The software doesn't properly control the boundaries of a buffer while parsing XML data, allowing an attacker to write data beyond the allocated space and potentially execute code.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-211;routerBalances[msg.sender][_local] can be inflated in repayAavePortal due to underflow in unchecked math;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113)

# Vulnerability details
    
    
      function repayAavePortal(
        address _local,
        uint256 _backingAmount,
        uint256 _feeAmount,
        uint256 _maxIn,
        bytes32 _transferId
      ) external {
        uint256 totalAmount = _backingAmount + _feeAmount; // in adopted
        uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local
    
        // Sanity check: has that much to spend
        if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();
    
        // Need to swap into adopted asset or asset that was backing the loan
        // The router will always be holding collateral in the local asset while the loaned asset
        // is the adopted asset
    
        // Swap for exact totalRepayAmount of adopted asset to repay aave
        (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(
          _local,
          totalAmount,
          _maxIn
        );
    
        if (!success) revert PortalFacet__repayAavePortal_swapFailed();
    
        // decrement router balances
        unchecked {
          s.routerBalances[msg.sender][_local] -= amountIn;
        }
    
        // back loan
        _backLoan(_local, _backingAmount, _feeAmount, _transferId);
      }

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L226-L250>
    
    
      function swapFromLocalAssetIfNeededForExactOut(
        address _asset,
        uint256 _amount,
        uint256 _maxIn
      )
        internal
        returns (
          bool,
          uint256,
          address
        )
      {
        AppStorage storage s = LibConnextStorage.connextStorage();
    
        // Get the token id
        (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);
    
        // If the adopted asset is the local asset, no need to swap
        address adopted = s.canonicalToAdopted[id];
        if (adopted == _asset) {
          return (true, _amount, _asset);
        }
    
        return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);
      }

When the _local is canonicalToAdopted,  AssetLogic.swapFromLocalAssetIfNeededForExactOut() will return the totalAmount as amountIn, and totalAmount is the total of two input values: _backingAmount + _feeAmount.

At L91, it checks for routerBalance < _maxIn, but there is no guarantee that _maxIn >= amountIn.

As a result, when repayAavePortal() is called with _backingAmount + _feeAmount > routerBalance and _local is an adopted asset, L108 will underflow, and the routerBalance can be inflated to a very high number.

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/RoutersFacet.sol#L591-L593>
    
    
      // Sanity check: amount can be deducted for the router
      if (routerBalance < _amount) revert RoutersFacet__removeRouterLiquidity_insufficientFunds();

The routerBalance is used for sanity check and once it's been inflated, the router can withdraw possibly all the funds in the contract.

### Recommendation

Generally, we suggest not to use unchecked in critical storage updates
    
    
        if (!success) revert PortalFacet__repayAavePortal_swapFailed();
    
        // decrement router balances
        s.routerBalances[msg.sender][_local] -= amountIn;
    
        // back loan
        _backLoan(_local, _backingAmount, _feeAmount, _transferId);
      }  
  
---  
  
The text was updated successfully, but these errors were encountered:   
  
?? 1 ecmendenhall reacted with thumbs up emoji

All reactions

  * ?? 1 reaction
...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This vulnerability is a classic example of CWE-20: Improper Input Validation. The code doesn't adequately validate that the '_maxIn' parameter is greater than or equal to the 'amountIn' calculated after the swap. This lack of validation allows for an attacker to manipulate the 'amountIn' value, leading to an underflow when subtracting from the 'routerBalance'.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-175;Missing whenNotPaused modifier;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L279-L286)

# Vulnerability details

## Impact

In StableSwapFacet.sol, two swapping functions contain the whenNotPaused modifier while swapExactOut() and addSwapLiquidity() do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.

## Proof of Concept

_**Example with modifier**_
    
    
      function swapExact(
        bytes32 canonicalId,
        uint256 amountIn,
        address assetIn,
        address assetOut,
        uint256 minAmountOut,
        uint256 deadline
      ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {
    

_**Examples without modifier**_
    
    
      function swapExactOut(
        bytes32 canonicalId,
        uint256 amountOut,
        address assetIn,
        address assetOut,
        uint256 maxAmountIn,
        uint256 deadline
      ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) {
    

and
    
    
      function addSwapLiquidity(
        bytes32 canonicalId,
        uint256[] calldata amounts,
        uint256 minToMint,
        uint256 deadline
      ) external nonReentrant deadlineCheck(deadline) returns (uint256) {
        return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);
      }
    

## Tools Used

Manual review.

## Recommended Mitigation Steps

Add the whenNotPaused modifier to all functions that perform swaps or liquidity additions...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-693: Protection Mechanism Failure;The code misses applying the 'whenNotPaused' modifier consistently to all relevant functions (swapExactOut and addSwapLiquidity), potentially allowing them to execute even when the contract is supposed to be paused. This inconsistency represents a failure in the intended protection mechanism.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-223;Current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge.;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L113-L192)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L194-L213>

# Vulnerability details

## Impact

Current implementation of arbitrary call execute failure handler may break some use case for example NFT Bridge.

In the case of NFT Bridge, NFT may be lost forever.

This is likely to be happened in the case of out of gas.

## Proof of Concept

Relayer receive the message to unlock BAYC on ETH chain. Relayer call execute on BridgeFacet which then call execute in Executor internally...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This vulnerability is most likely related to CWE-20: Improper Input Validation. The description mentions 'arbitrary call execute failure handler' and how it could 'break some use case' like an NFT bridge. This suggests the code may not be adequately validating inputs or handling unexpected failures during execution, potentially leading to unintended consequences.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-154;Did Not Approve To Zero First Causing Certain Token Transfer To Fail;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347>

# Vulnerability details

## Proof-of-Concept

Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s approve() function will revert if the current approval is not zero, to protect against front-running changes of approvals.

#### Instance 1 - BridgeFacet._reconcileProcessPortal

The following function must be approved by zero first, and then the  SafeERC20.safeIncreaseAllowance function can be called...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-494;The code references an external dependency that introduces a security weakness. In this case, the vulnerability arises from the specific implementation of the `approve()` function in certain tokens like USDT, where changing an existing non-zero allowance can lead to a revert. This behavior, while intended to prevent front-running, creates a dependency on the specific token's implementation and makes the code susceptible to errors.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-160;Bridging could be temporarily disrupted when setConnext is called without deactivating sponsorVault;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L827-L850)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/SponsorVault.sol#L138-L140>

# Vulnerability details

When a sponsor wants to stop sponsoring bridge fees, it's possible that they call SponsorVault.setConnext to stop allowing Connext to reimburse fees, but forgot to inform the Connext team. This will cause bridging executions to be temporarily disrupted.

For fee reimbursement to work, both the Bridge and SponsorVault must point to each other...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition;The vulnerability arises because there's a time gap between checking the sponsor status and the bridge execution. The sponsor status can change within this gap, leading to a race condition.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-196;_handleExecuteTransaction may not working correctly on fee-on-transfer tokens. Moreover, if it is failed, fund may be locked forever.;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L856-L877)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L142-L144>  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L160-L166>  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/Executor.sol#L194-L213>

# Vulnerability details

## Impact

_handleExecuteTransaction may not working correctly on fee-on-transfer tokens. As duplicated fee is applied to fee on transfer token when executing a arbitrary call message passing request...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This vulnerability appears to be related to improper input validation, specifically how fee-on-transfer tokens are handled during execution, potentially leading to unexpected double fee application. ;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-145;Router Owner Could Steal All The Funds Within SponsorVault;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L541)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/SponsorVault.sol#L196>

# Vulnerability details

## Proof-of-Concept

Assume the following:

  * For simplity sake, only two (2) routers exist within Connext. Router A has 1,000,000 oUSDC on Optimism Domain/Chain
  * Router B has only 100 oUSDC on Optimism Domain/Chain
  * The liquidity fee is 5% for fast transfer service
  * SponserVault will reimbursed 50% of the liquidity fee incurred by the users

At this point, attacker balances are as follows (2,000,000 USDC in total)

> Attacker's wallet in Ethereum = 1,000,000 USDC
> 
> Attacker's wallet in Optimism = 0 oUSDC
> 
> Attacker's router in Optimism = 1,000,000 oUSDC

First, the attacker attempts to transfer an extremely large amount - 1,000,000 USDC from attacker's address in Ethereum to attacker's address in Optimism Chain...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-476: NULL Pointer Dereference;While the description doesn't explicitly mention NULL pointer dereference, the scenario implies exploiting insufficient validation or edge cases related to handling large transfers and liquidity pools, potentially leading to unexpected behavior like a NULL pointer dereference in the context of the provided code. Further analysis of the code is needed to confirm this.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-147;Malicious Relayers Could Favor Their Routers;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L636)

# Vulnerability details

## Vulnerability Details

Assume that a malicious relayer operates a router in Connext providing fast-liquidity service. A malicious relayer could always swap the router(s) within the execute calldata with the router(s) owned by malicious relayer, and submit it to the chain for execution.

## Proof-of-Concept

This example assumes a fast-liquidity path...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-494: Download of Code Without Integrity Check;The vulnerability arises because the Connext bridge contract doesn't verify the integrity of the router(s) specified in the calldata before execution. This allows a malicious relayer to substitute the intended routers with their own, potentially redirecting funds or executing malicious code.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-234;Malicious relayer could exploit sponsor vaults;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/SponsorVault.sol#L234-L263)

# Vulnerability details

## Impact

Sponsor vaults drained

## Proof of Concept

reimburseRelayerFees uses SponsorVault funds to repay users the fees they pay to relayers. A malicious relayer could create a large number of transactions with the max reimbursed relay fee specified in SponsorVault between chains for which they relay all of them...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-400;This vulnerability appears to be a type of Resource Exhaustion (CWE-400), specifically due to Uncontrolled Resource Consumption. A malicious actor (the relayer) can manipulate the system to consume an excessive amount of resources (SponsorVault funds), leading to a denial of service.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-181;BridgeFacet's _executePortalTransfer ignores underlying token amount withdrawn from Aave pool;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900)

# Vulnerability details

_executePortalTransfer can introduce underlying token deficit by accounting for full underlying amount received from Aave unconditionally on what was actually withdrawn from Aave pool. Actual amount withdrawn is returned by IAavePool(s.aavePool).withdraw(), but currently is not used.

Setting the severity to medium as this can end up with a situation of partial insolvency, when where are a surplus of atokens, but deficit of underlying tokens in the bridge, so bridge functionality can become unavailable as there will be not enough underlying tokens, which were used up in the previous operations when atokens wasn't converted to underlying fully and underlying tokens from other operations were used up instead without accounting...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This vulnerability falls under CWE-20: Improper Input Validation. The code doesn't adequately validate the actual amount of tokens withdrawn from the Aave pool, relying on an assumed value instead of the actual returned value.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-151;Precision Loss During Division;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L757)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L541>

# Vulnerability details

## Proof-of-Concept

Assume that toSwap = 10 DAI and pathLen = 3 in this example.

Therefore, the bridge will pull 10 DAI from the RouterFacet contract. However, within the [BridgeFacet._handleExecuteLiquidity](<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L757>) function, due to precision loss when solidity handles division of integer, the following code will result in routerAmount to be evaluted to 3:
    
    
    // @audit-issue (10 / 3 = 3)
    uint256 routerAmount = toSwap / pathLen;

The code will then proceed to deduct the liquidity from all the 3 routers equally:

  * Router A = -3 DAI

  * Router B = -3 DAI

  * Router C = -3 DAI

A total of -9 DAI is deducted from the 3 routers...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-1333;This code demonstrates CWE-1333 (Integer Overflow or Wraparound) as it doesn't account for potential rounding errors when dividing integers. This can lead to unexpected behavior like deducting less than the intended amount in this example.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-144;Malicious Relayer Can Replay Execute Calldata On Different Chains Causing Double-Spend Issue;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411)

# Vulnerability details

## Proof-of-Concept

> This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.

First, the attacker will attempt to use Connext to send 1000 USDC from Ethereum domain to Optimism domain.

Assume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext [BridgeFacet.execute](<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411>) function.

Optimism's Connext BridgeFacet.execute received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-416: Use After Free;The vulnerability lies in the potential for a malicious relayer in the Connext fast-transfer mechanism to manipulate calldata, leading to a situation where memory allocated for a transaction is freed and then potentially accessed again, resulting in unpredictable behavior.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-149;Malicious Relayer Could Cause A Router To Provide More Liquidity Than It Should;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L636)

# Vulnerability details

## Proof-of-Concept

Assume this is a fast-transfer path and the sequencer has a good reason (e.g. some sophisticated liquidity load balancing algorithm) to assign 3 routers to provide liquidity for a transfer of 90 DAI

Therefore, each of them will provide 30 DAI equally.

> _args.routers[] array = [Router A, Router B, Router C]

However, a malicious relayer could rearrange the _args.routers[] array to any of the following and still pass the sanity checks within [BridgeFacet._executeSanityChecks](<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L636>)

> _args.routers[] array = [Router A, Router A, Router A]
> 
> _args.routers[] array = [Router A, Router A, Router B]
> 
> _args.routers[] array = [Router A, Router A, Router C]
> 
> _args.routers[] array = [Router C, Router A, Router C]

The point is that as long as the attacker ensures that the pathLength is correct, he will be able to pass the router check within [BridgeFacet._executeSanityChecks](<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L636>).

Assume that malicious relayer decided to rearrange the _args.routers[] array to as follows, this will cause Router A to provide more liquidity than it should be and overwrite the sequencer decision...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-497;The vulnerability arises from the possibility of a malicious relayer manipulating the order of routers in the '_args.routers[]' array. This manipulation allows the attacker to bypass the intended liquidity distribution and force a specific router to provide more liquidity than originally assigned by the sequencer. This falls under CWE-497, which deals with 'Exposure of Resources to Wrong Sphere'.  The code exposes the control over the router sequence to a potentially untrusted entity (the relayer), leading to a security vulnerability.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-158;Incorrect check in diamondCut allows update be executed without proposal;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103)

# Vulnerability details

The current implementation of LibDiamond.diamondCut allows any diamondCut update to be executed instantly, defeating the purpose of the 7 day update delay mechanism.

The issue is this check in LibDiamond.diamondCut:
    
    
    require(
      diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,
      ""LibDiamond: delay not elapsed""
    );
    

As acceptanceTimes has the default value of 0, any updates that have never been proposed will satisfy the < block.timestamp condition. A malicious or compromised governance can exploit this to add a malicious upgrade instantly.

## Recommended Mitigation Steps

Add another check to guard against this:
    
    
    require(
        diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0,
        ""LibDiamond: not proposed yet""
    );
      
  
---  
  
The text was updated successfully, but these errors were encountered:   
  
All reactions
...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-399: Resource Management Errors;The code fails to properly manage the 'acceptanceTimes' resource, specifically not handling the default value of 0. This oversight allows bypassing the intended time delay and permits immediate execution of diamondCut updates.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-241;Diamond upgrade proposition can be falsified;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/DiamondCutFacet.sol#L16-L29)  
<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L94-L118>  
<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L222-L240>

# Vulnerability details

## Impact

Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice.

## Proof of Concept

To determine the id of the proposal, only its facet changes are hashed, skipping two critical pieces of data - the _init and _calldata...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition;The vulnerability arises from a race condition where the proposal ID is calculated based on incomplete data. An attacker can potentially manipulate this by proposing a seemingly harmless upgrade, then swapping it with a malicious one before execution, exploiting the time gap between checking the proposal and executing it.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-204;Tokens with decimals larger than 18 are not supported;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115)

# Vulnerability details

For tokens with decimals larger than 18, many functions across the codebase will revert due to underflow.

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115>
    
    
    function getPriceFromDex(address _tokenAddress) public view returns (uint256) {
        PriceInfo storage priceInfo = priceRecords[_tokenAddress];
        if (priceInfo.active) {
          uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);
          uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());
          uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);
          uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);
          uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());
          uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);
          uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);
          uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);
    
          return tokenPrice;
        } else {
          return 0;
        }
      }

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L426>
    
    
    precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]);

Chainlink feeds' with decimals &gt; 18 are not supported neither:

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140>
    
    
    function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {
        AggregatorV3Interface aggregator = aggregators[_tokenAddress];
        if (address(aggregator) != address(0)) {
          (, int256 answer, , , ) = aggregator.latestRoundData();
    
          // It's fine for price to be 0. We have two price feeds.
          if (answer == 0) {
            return 0;
          }
    
          // Extend the decimals to 1e18.
          uint256 retVal = uint256(answer);
          uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));
    
          return price;
        }
    
        return 0;
      }

### Recommendation

Consider checking if decimals &gt; 18 and normalize the value by div the decimals difference...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-190;The code performs calculations involving token amounts without adequately accounting for tokens with decimals exceeding 18. This can lead to integer underflows, resulting in incorrect calculations or potential security vulnerabilities.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-215;LibDiamond.diamondCut() should check diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103)  
<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79>  
<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90>

# Vulnerability details

## Impact

Normally, diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] will be set in LibDiamond.proposeDiamondCut(). Then in LibDiamond.diamondCut(), it checks that diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp.

However, LibDiamond.rescindDiamondCut() will set diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] to 0...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition;The code suffers from a time-of-check to time-of-use vulnerability. The `acceptanceTimes` value is checked and later used in `diamondCut`, but  `rescindDiamondCut` can modify this value in between, leading to potential inconsistencies or unauthorized operations.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-159;diamondCut doesn't validate _init and _calldata;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibDiamond.sol#L95-L118)

# Vulnerability details

Malicious or compromised governance can send a different _init and _calldata payload than the one that was proposed. An attacker can pretend to propose a safe upgrade and later execute a delegatecall to steal funds or selfdestruct the system.

## Proof of Concept

  * Malicious governor proposed a normal update with empty payload for _init and _calldata.
  * After the update delay has passed, the governor executes the update with _init pointing to a malicious contract, stealing funds from the system.

## Recommended Mitigation Steps

Consider hashing _init and _calldata alongside _diamondCut as the acceptanceTimes key, to ensure the execution will use the same payload.
    
    
    // @audit Apply to rescindDiamondCut() and diamondCut() as well.
    function proposeDiamondCut(
        IDiamondCut.FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        uint256 acceptance = block.timestamp + _delay;
        diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))] = acceptance;
        emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);
    } 
      
  
---  
  
The text was updated successfully, but these errors were encountered:   
  
All reactions
...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-497;This vulnerability falls under **CWE-497: Exposure of Security Decision-Making to Untrusted Entities**. The Connext protocol allows a malicious or compromised governance entity to alter the upgrade proposal's execution payload (_init and _calldata) after it has been approved. This means that even if users scrutinize and approve a seemingly safe upgrade, the attacker can swap it with a malicious one at the execution stage.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-222;In execute() the amount routers pay is what user signed, but in _reconcile() the amount routers get is what nomad sends and this two amount are not necessary equal because of slippage in original domain;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L526-L616)  
<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L753-L803>  
<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L398-L428>  
<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L345-L351>

# Vulnerability details

## Impact

routers pay for transaction in destination domain then nomad messages come and routers get paid again. but the amount routers pay in execute() are what transaction sender signed and the amount routers receive is what nomad sends and handles in _reconcile() but this two amount can be different because of slippage and swap that happens in xcall() because the amount sent in nomad message is the result of swapToLocalAssetIfNeeded()...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This vulnerability falls under the category of  **CWE-20: Improper Input Validation**. The core issue lies in the lack of validation or improper validation of the amount received from the Nomad bridge compared to the amount originally paid by the router. An attacker can potentially exploit this discrepancy to receive a larger reimbursement than what they initially spent.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-213;division rounding error in _handleExecuteLiquidity() and _reconcile() make routerBalances and contract fund balance to get out of sync and cause fund lose;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L753-L803)  
<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L526-L616>

# Vulnerability details

## Impact

variable routerBalances suppose to keep track of routers balance in contract and routers can withdraw their balance from contract. but because of division rounding error in _handleExecuteLiquidity() and _reconcile() contract uses more of its tokens than it subtract from router's balance...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-369;This vulnerability stems from an integer division rounding error. Attackers could exploit this error to potentially manipulate funds, especially over many transactions.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-220;Relayer Will Not Receive Any Fee If execute Reverts;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L415)

# Vulnerability details

## Proof-of-Concept

Connext relies on the relayer to trigger the BridgeFacet.execute function on the destination domain to initiate the token transfer and calldata execution processes. Relayers pay for the gas cost to trigger the execute function, and in return for their effort, they are reimbused with the relayer fee.

However, it is possible that the BridgeFacet.execute function will revert under certain circumstances when triggered by the relayers...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-476: NULL Pointer Dereference;While the description doesn't explicitly mention NULL pointer dereference, the mention of `BridgeFacet.execute` function reverting under certain circumstances indicates a possibility that the code might not be handling all error conditions or edge cases properly. This could lead to scenarios like trying to access an object or resource that doesn't exist, similar to a NULL pointer dereference.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-143;Routers Are Not Enforced To Repay AAVE Portal Loan;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)

# Vulnerability details

## Background

#### AAVE Portal

AAVE portal provides a trusted credit line that allows bridges to take on an unbacked position, and Connext intents to use this credit line to provide fast-liquidity for its users in the event the routers do not have sufficient liquidity.

Connext will assign one (1) router to be responsible for taking on credit risk of borrowing an unbacked position from AAVE portal as per [Source Code](<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L777>)

Under normal circumstance, the BridgeFacet._reconcile function will automatically repay back the loan to AAVE portal when the nomad message arrives. However, if the repayment fails for certain reason, Connext expects that the router will use the [repayAavePortal](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function out-of-band to help Connext to repay the loan.

Ultimately, it is Connext that take on the credit risk because AAVE portal only provides a trusted credit line to Connext, but not to the individual routers.

#### Nomad Message

When nomad message arrives, it will call BridgeFacet.handle function, which will in turn trigger the internal _reconcile function...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-733;The code relies on a specific router to repay a loan in case of reconciliation failures, but lacks a mechanism to enforce or incentivize this repayment, potentially leading to Connext bearing the credit risk if the router defaults.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-240;Diamond can be updated without proposing the change;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/DiamondCutFacet.sol#L16-L29)  
<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L94-L118>  
<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L222-L240>

# Vulnerability details

## Impact

The diamond shall be monitored externally to remove the need of trust to developers...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-362;This vulnerability appears to stem from a lack of proper synchronization or atomicity guarantees when updating the diamond's state. An attacker could potentially exploit race conditions to manipulate the diamond's behavior.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-225;attacker can perform griefing for process() in PromiseRouter by reverting calls to callback() in callbackAddress;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/promise/PromiseRouter.sol#L226-L262)

# Vulnerability details

## Impact

process() in PromiseRouter  is used for process stored callback function and anyone calls it gets callbackFee and it calls callback() function of callbackAddress. but attacker set a callbackAddress that reverts on callback() and cause process() caller griefing...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-476;This vulnerability falls under **CWE-476: NULL Pointer Dereference**. Although not explicitly a NULL pointer, the core issue lies in calling a function (callback()) on an address (callbackAddress) that is controlled by the attacker. When the attacker sets this address to a contract that reverts, it leads to a denial of service, effectively making the `process()` function unusable due to the attacker's manipulation. This aligns with the core concept of CWE-476, where an assumption about a reference being valid is violated.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-249;Swaps done internally will be not be possible;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L346)  
<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L812>

# Vulnerability details

Affected functions(that rely on swapAsset()) are:

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193>

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159>

swapAsset() facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to

s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments (due to an incorrect ordering, this seemed to be an oversight, acknowledged by #Layne) :

<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279>

Based on the above mentioned code , the arguments would be incorrectly changed to :

<https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745>

The condition checked here:

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750>

will never be true as the msg.sender would never own the quantity of tokens being swapped from since it's the wrong token...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20: Improper Input Validation;The vulnerability arises from an incorrect order of arguments passed to the `swapInternal()` function in the Connext protocol. This improper argument passing, stemming from a logic error, leads to a condition where the intended swap operation will consistently fail. The root cause is a lack of validation or proper handling of the order of arguments, highlighting an input validation flaw.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-199;Timelock able to be bypassed because of wrong check in LibDiamond;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/LibDiamond.sol#L101)

# Vulnerability details

## Impact

In the walkthrough video, it said that the upgrades of Diamond must go through a proposal window with a delay of 7 days. If owner not call proposeDiamondCut then acceptanceTimes is default value which is 0 and the check will always pass.

This is very dangerous when admin can use all privileges without a delay, including withdraw all the funds.

Please refer to [this issue](<https://github.com/code-423n4/2021-11-malt-findings/issues/263>) to check the severity when timelock can be bypassed.

## Proof of Concept

  1...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-862: Missing Authorization;The code fails to enforce a timelock (a form of authorization) before allowing critical functions like diamond upgrades. This could allow an attacker to bypass intended security measures.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-202;Wrong implementation of withdrawAdminFees() can cause the adminFees to be charged multiple times and therefore cause users' fund loss;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062)

# Vulnerability details
    
    
    function withdrawAdminFees(Swap storage self, address to) internal {
      IERC20[] memory pooledTokens = self.pooledTokens;
      for (uint256 i = 0; i < pooledTokens.length; i++) {
        IERC20 token = pooledTokens[i];
        uint256 balance = self.adminFees[i];
        if (balance != 0) {
          token.safeTransfer(to, balance);
        }
      }
    }

self.adminFees[i] should be reset to 0 every time it's withdrawn. Otherwise, the adminFees can be withdrawn multiple times.

The admin may just be unaware of this issue and casualty withdrawAdminFees() from time to time, and rug all the users slowly.

### Recommendation

Change to:
    
    
    function withdrawAdminFees(Swap storage self, address to) internal {
      IERC20[] memory pooledTokens = self.pooledTokens;
      for (uint256 i = 0; i < pooledTokens.length; i++) {
        IERC20 token = pooledTokens[i];
        uint256 balance = self.adminFees[i];
        if (balance != 0) {
          self.adminFees[i] = 0;
          token.safeTransfer(to, balance);
        }
      }
    }  
  
---  
  
The text was updated successfully, but these errors were encountered:   
  
All reactions
...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This code suffers from CWE-20: Improper Input Validation. The vulnerability arises because the code doesn't properly validate or handle the state of `self.adminFees` after a withdrawal. This omission allows an attacker to repeatedly withdraw admin fees, potentially draining funds over time. The input validation issue here isn't about external data, but rather about the internal state of the contract.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-150;Router Owner Could Be Rugged By Admin;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293)  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490>  
<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212>

# Vulnerability details

## Proof-of-Concept

Assume that Alice's router has large amount of liquidity inside.

Assume that the Connext Admin decided to remove a router owned by Alice. The Connext Admin will call the RoutersFacet.removeRouter function, and all information related to Alice's router will be erased (set to 0x0) from the s.routerPermissionInfo.

<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293>
    
    
      function removeRouter(address router) external onlyOwner {
        // Sanity check: not empty
        if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();
    
        // Sanity check: needs removal
        if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();
    
        // Update mapping
        s.routerPermissionInfo.approvedRouters[router] = false;
    
        // Emit event
        emit RouterRemoved(router, msg.sender);
    
        // Remove router owner
        address _owner = s.routerPermissionInfo.routerOwners[router];
        if (_owner != address(0)) {
          emit RouterOwnerAccepted(router, _owner, address(0));
          // delete routerOwners[router];
          s.routerPermissionInfo.routerOwners[router] = address(0);
        }
    
        // Remove router recipient
        address _recipient = s.routerPermissionInfo.routerRecipients[router];
        if (_recipient != address(0)) {
          emit RouterRecipientSet(router, _recipient, address(0));
          // delete routerRecipients[router];
          s.routerPermissionInfo.routerRecipients[router] = address(0);
        }
    
        // Clear any proposed ownership changes
        s.routerPermissionInfo.proposedRouterOwners[router] = address(0);
        s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;
      }

Alice is aware that her router has been removed by Connext Admin, so she decided to withdraw the liquidity from her previous router by calling RoutersFacet.removeRouterLiquidityFor.

However, when Alice called the RoutersFacet.removeRouterLiquidityFor function, it will revert every single time...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-704: Direct Request ('Forced Browsing');The vulnerability arises because the Connext Admin can remove a router's permissions, effectively blocking the owner from withdrawing their own liquidity. While the code attempts to prevent issues by checking for an empty router address and ensuring the router needs removal, it fails to account for a scenario where the Admin removes a router with existing liquidity.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-165;AssetLogic's _swapAssetOut can fail on the one step approval;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L346-L349)

# Vulnerability details

_swapAssetOut() performs one step approval for an arbitrary _assetIn before calling pool's swapExactOut(). As ERC20 that do not allow approval race condition prohibit setting approval to a new positive value when allowance is positive already, this call will fail if _assetIn happens to be such a token.

It can happen as _swapAssetOut has to deal with arbitrary tokens and swapping can produce leftover allowance for the next runs by not utilizing current amount fully.

Setting severity to medium as that situation will render _swapAssetOut and all the upstream functionality unavailable for such a tokens: all successive calls will be reverted until allowance be used up or reset.

## Proof of Concept

_swapAssetOut() approves positive _amountIn of _assetIn in one step:

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L346-L349>
    
    
            // perform the swap
            SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);
            amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);
          }

Some tokens do not let to approve new positive allowance from current positive allowance to protect against race condition when the allowance can be double spent, simply reverting any attempt to approve positive from positive:

<https://github.com/d-xo/weird-erc20#approval-race-protections>

For example current USDT contract, L205:

<https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code>

## Recommended Mitigation Steps

The recommendation is to set approval to zero first, then to set it to _amountIn.

It's the same as described in the another occurrence of the same issue in BridgeFacet:

<https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1027-L1029>  
  
---  
  
The text was updated successfully, but these errors were encountered:   
  
All reactions
...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;The code suffers from improper input validation as it does not account for ERC20 tokens that disallow setting a new positive allowance when a positive allowance already exists. This oversight can lead to denial-of-service, as subsequent swaps using such tokens will continuously revert.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-237;in reimburseLiquidityFees() of SponserVault contract swaps tokens without slippage limit so its possible to perform sandwich attack and it create MEV;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/SponsorVault.sol#L187-L220)

# Vulnerability details

## Impact

when code swaps tokens it should specify slippage but in reimburseLiquidityFees() code contract calls  tokenExchange.swapExactIn() without slippage and it's possible to perform sandwich attack and make contract to swap on bad exchange rates and there is MEV.

## Proof of Concept

This is reimburseLiquidityFees() code in SponserVault :
    
    
      /**
       * @notice Performs liquidity fee reimbursement.
       * @dev Uses the token exchange or liquidity deposited in this contract.
       *      The _receiver address is only used for emitting in the event.
       * @param _token The address of the token
       * @param _liquidityFee The liquidity fee amount
       * @param _receiver The address of the receiver
       * @return Sponsored liquidity fee amount
       */
      function reimburseLiquidityFees(
        address _token,
        uint256 _liquidityFee,
        address _receiver
      ) external override onlyConnext returns (uint256) {
        uint256 sponsoredFee;
    
        if (address(tokenExchanges[_token]) != address(0)) {
          uint256 currentBalance = address(this).balance;
          ITokenExchange tokenExchange = tokenExchanges[_token];
    
          uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);
          amountIn = currentBalance >= amountIn ? amountIn : currentBalance;
    
          // sponsored fee may end being less than _liquidityFee due to slippage
          sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);
        } else {
          uint256 balance = IERC20(_token).balanceOf(address(this));
          sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;
    
          // some ERC20 do not allow to transfer 0 amount
          if (sponsoredFee > 0) {
            IERC20(_token).safeTransfer(msg.sender, sponsoredFee);
          }
        }
    
        emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);
    
        return sponsoredFee;
      }
    

As you can see there is no slippage defined when calling swapExactIn() can that swap could happen in any exchange rate. and it's also MEV opportunity.

## Tools Used

VIM

## Recommended Mitigation Steps

specify slippage when calling swap tokens...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-20;This vulnerability falls under **CWE-20: Improper Input Validation**. The code fails to validate or control the slippage rate when swapping tokens using `swapExactIn()`.  This lack of slippage control allows attackers to manipulate exchange rates (e.g., through sandwich attacks), forcing the contract to execute trades at unfavorable prices.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-216;function removeRouter() in RouterFacet don't check that router has balance and don't transfer it, it just set router owner and recipient to 0x0 which can cause make router balance in danger or unavailable for router owner;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/RoutersFacet.sol#L289-L325)

# Vulnerability details

## Impact

There are some security levels for router, like setting owner and recipient and when removeRouter() is called this values set to 0x0 and router address become vulnerable. contract should transfer router balance to recipient before removing it.

## Proof of Concept

This is removeRouter() code:
    
    
      /**
       * @notice Used to remove routers that can transact crosschain
       * @param router Router address to remove
       */
      function removeRouter(address router) external onlyOwner {
        // Sanity check: not empty
        if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();
    
        // Sanity check: needs removal
        if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();
    
        // Update mapping
        s.routerPermissionInfo.approvedRouters[router] = false;
    
        // Emit event
        emit RouterRemoved(router, msg.sender);
    
        // Remove router owner
        address _owner = s.routerPermissionInfo.routerOwners[router];
        if (_owner != address(0)) {
          emit RouterOwnerAccepted(router, _owner, address(0));
          // delete routerOwners[router];
          s.routerPermissionInfo.routerOwners[router] = address(0);
        }
    
        // Remove router recipient
        address _recipient = s.routerPermissionInfo.routerRecipients[router];
        if (_recipient != address(0)) {
          emit RouterRecipientSet(router, _recipient, address(0));
          // delete routerRecipients[router];
          s.routerPermissionInfo.routerRecipients[router] = address(0);
        }
    
        // Clear any proposed ownership changes
        s.routerPermissionInfo.proposedRouterOwners[router] = address(0);
        s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;
      }
    

As you can see there is no check for router balances and owner can set all the security variables for router address to 0x0 and router balance would be in danger...";RTI Connext DDS;19/06/2022 00:00;0;;;CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition;The code does not consider the possibility that the router's balance could change between the time the `removeRouter` function is called and the time the security variables are reset to 0x0. This could allow an attacker to drain the router's balance by performing a transfer after the checks but before the state is fully updated.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-68;PortcalFacet.repayAavePortal() can trigger an underflow of routerBalances;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113)

# Vulnerability details

## Impact

The caller of repayAavePortal() can trigger an underflow to arbitrarily increase the caller's balance through an underflow.

## Proof of Concept
    
    
    // Relevant code sections:
    
    // PortalFacet.sol
      function repayAavePortal(
        address _local,
        uint256 _backingAmount,
        uint256 _feeAmount,
        uint256 _maxIn,
        bytes32 _transferId
      ) external {
        uint256 totalAmount = _backingAmount + _feeAmount; // in adopted
        uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local
    
        // Sanity check: has that much to spend
        if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();
    
        // Need to swap into adopted asset or asset that was backing the loan
        // The router will always be holding collateral in the local asset while the loaned asset
        // is the adopted asset
    
        // Swap for exact totalRepayAmount of adopted asset to repay aave
        (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(
          _local,
          totalAmount,
          _maxIn
        );
    
        if (!success) revert PortalFacet__repayAavePortal_swapFailed();
    
        // decrement router balances
        unchecked {
          s.routerBalances[msg.sender][_local] -= amountIn;
        }
    
        // back loan
        _backLoan(_local, _backingAmount, _feeAmount, _transferId);
      }
    
    // AssetLogic.sol
      function swapFromLocalAssetIfNeededForExactOut(
        address _asset,
        uint256 _amount,
        uint256 _maxIn
      )
        internal
        returns (
          bool,
          uint256,
          address
        )
      {
        AppStorage storage s = LibConnextStorage.connextStorage();
    
        // Get the token id
        (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);
    
        // If the adopted asset is the local asset, no need to swap
        address adopted = s.canonicalToAdopted[id];
        if (adopted == _asset) {
          return (true, _amount, _asset);
        }
    
        return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);
      }

First, call repayAavePortal() where _backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]. That will trigger the call to the AssetLogic contract:
    
    
        (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(
          _local,
          totalAmount,
          _maxIn
        );

By setting _local to the same value as the adopted asset, you trigger the following edge case:
    
    
        address adopted = s.canonicalToAdopted[id];
        if (adopted == _asset) {
          return (true, _amount, _asset);
        }

So the amountIn value returned by swapFromLocalAssetIfNeededForExactOut() is the totalAmount value that was passed to it...";RTI Connext DDS;14/06/2022 00:00;0;;;CWE-191;The code performs an arithmetic operation that can result in an integer underflow, potentially leading to unexpected behavior such as wrapping around to a large positive value. In this instance, an attacker can manipulate input parameters to trigger the underflow and increase their balance.;Vulners
CODE423N4:2022-06-CONNEXT-FINDINGS-ISSUES-70;Integer overflow can affect router balances;"[Lines of code](https://github.com/code-423n4/2022-06-connext/blob/20f86d58444d7c8178735ada7e456a3112116e54/contracts/contracts/core/connext/facets/PortalFacet.sol#L108)

# Vulnerability details

## Impact

Integer overflow can affect router balances.

## Proof of Concept

The repayAavePortal method of the PortalFacet contract subtracts the balance within an unchecked region, but this balance is not checked beforehand to be greater than the amountIn.
    
    
    unchecked { s.routerBalances[msg.sender][_local] -= amountIn; }

The unique check against the balance is with the _maxIn that always could be greater than the balance because apparently is use as slippage (is not documented as a @param in the methods).
    
    
    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();

## Recommended Mitigation Steps

Remove the unchecked region...";RTI Connext DDS;14/06/2022 00:00;0;;;CWE-191;The code performs an arithmetic operation that can overflow or underflow the bounds of an integer data type, leading to unexpected behavior. In this case, subtracting  'amountIn' from 's.routerBalances[msg.sender][_local]' without ensuring the result is non-negative allows for potential underflow.;Vulners
NVD:CVE-2021-38433;CVE-2021-38433;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 17:15;78;HIGH;;CWE-787;CWE-787 (Out-of-bounds Write) occurs when data is written past the intended bounds of a buffer, potentially leading to overwriting adjacent data or code execution.;Vulners
NVD:CVE-2021-38435;CVE-2021-38435;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 not correctly calculate the size when allocating the buffer, which may result in a buffer overflow.;RTI Connext DDS;05/05/2022 17:15;98;CRITICAL;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when software fails to properly manage boundaries when handling data stored in a buffer, allowing data to exceed the allocated buffer space and overwrite adjacent memory locations.;Vulners
NVD:CVE-2021-38487;CVE-2021-38487;RTI Connext DDS Professional, Connext DDS Secure versions 4.2x to 6.1.0, and Connext DDS Micro versions 2.4 and later are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;RTI Connext DDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The attacker can send crafted packets that consume excessive resources (bandwidth, processing power), leading to a denial of service.;Vulners
CVE-2021-38433;CVE-2021-38433;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 17:15;78;HIGH;;CWE-787;This vulnerability is a classic example of a stack-based buffer overflow. The description states that a local attacker can exploit this vulnerability to execute arbitrary code, which is a direct consequence of writing data past the allocated buffer on the stack.;Vulners
CVE-2021-38435;CVE-2021-38435;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 not correctly calculate the size when allocating the buffer, which may result in a buffer overflow.;RTI Connext DDS;05/05/2022 17:15;98;CRITICAL;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input) occurs as the software does not properly calculate the size of the buffer needed to store data, potentially leading to a buffer overflow.;Vulners
NVD:CVE-2021-38427;CVE-2021-38427;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2.x to 6.1.0 are vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 17:15;78;HIGH;;CWE-787;This vulnerability is a classic example of a stack-based buffer overflow (CWE-787). The description states that a local attacker can exploit the vulnerability to execute arbitrary code. This typically occurs when data written to a buffer on the stack exceeds the allocated space, overwriting adjacent memory and potentially allowing the attacker to hijack the program's execution flow.;Vulners
CVE-2021-38487;CVE-2021-38487;RTI Connext DDS Professional, Connext DDS Secure versions 4.2x to 6.1.0, and Connext DDS Micro versions 2.4 and later are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;RTI Connext DDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The attacker can exploit the vulnerability to flood the target devices with excessive traffic, leading to resource exhaustion and denial of service.;Vulners
CVE-2021-38427;CVE-2021-38427;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2.x to 6.1.0 are vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 17:15;78;HIGH;;CWE-787;This vulnerability is classified as a 'Out-of-bounds Write' because the software writes data past the end of the allocated buffer on the stack. This can overwrite critical data and allow arbitrary code execution.;Vulners
PRION:CVE-2021-38487;Design/Logic Flaw;RTI Connext DDS Professional, Connext DDS Secure versions 4.2x to 6.1.0, and Connext DDS Micro versions 2.4 and later are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;RTI Connext DDS;05/05/2022 17:15;64;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The attacker can flood the target devices with traffic, leading to excessive resource consumption and potential denial of service.;Vulners
PRION:CVE-2021-38427;Stack overflow;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2.x to 6.1.0 are vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 17:15;46;;;CWE-787;This vulnerability is a classic case of a stack-based buffer overflow. The software does not properly validate the length of data being copied into a stack-allocated buffer, allowing an attacker to overwrite adjacent memory and potentially execute malicious code.;Vulners
PRION:CVE-2021-38435;Buffer overflow;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 not correctly calculate the size when allocating the buffer, which may result in a buffer overflow.;RTI Connext DDS;05/05/2022 17:15;75;;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when software writing to a buffer overwrites adjacent memory locations due to insufficient bounds checking, potentially leading to crashes or arbitrary code execution.;Vulners
PRION:CVE-2021-38433;Stack overflow;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 17:15;46;;;CWE-787;CWE-787 (Out-of-bounds Write) occurs when data is written past the boundaries of a buffer.  In this case, the stack-based buffer overflow in RTI Connext DDS allows writing beyond the allocated buffer on the stack, potentially overwriting critical program data and leading to arbitrary code execution.;Vulners
CVELIST:CVE-2021-38435;CVE-2021-38435 RTI Connext DDS Professional and Connext DDS Secure Incorrect Calculation of Buffer Size;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 not correctly calculate the size when allocating the buffer, which may result in a buffer overflow.;RTI Connext DDS;05/05/2022 15:27;66;MEDIUM;;CWE-122;CWE-122 (Heap-based Buffer Overflow) occurs as the software does not correctly calculate the size of the buffer when allocating it on the heap, potentially leading to an overflow during write operations.;Vulners
CVELIST:CVE-2021-38433;CVE-2021-38433 RTI Connext DDS Professional and Connext DDS Secure Stack-based Buffer Overflow;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2x to 6.1.0 vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 15:27;66;MEDIUM;;CWE-787;This vulnerability is a classic case of a stack-based buffer overflow.  The vulnerability exists due to insufficient bounds checking during a copy operation, allowing an attacker to overflow a buffer on the stack and potentially execute arbitrary code.;Vulners
CVELIST:CVE-2021-38427;CVE-2021-38427 RTI Connext DDS Professional and Connext DDS Secure Stack-based Buffer Overflow;RTI Connext DDS Professional and Connext DDS Secure Versions 4.2.x to 6.1.0 are vulnerable to a stack-based buffer overflow, which may allow a local attacker to execute arbitrary code.;RTI Connext DDS;05/05/2022 15:25;66;MEDIUM;;CWE-787;This vulnerability is classified as CWE-787: Out-of-bounds Write.  The description indicates a 'stack-based buffer overflow,' which means data is being written past the allocated memory space on the stack. This is a classic example of an out-of-bounds write.;Vulners
CVELIST:CVE-2021-38487;CVE-2021-38487 RTI Connext DDS Professional and Connext DDS Secure Network Amplification;RTI Connext DDS Professional, Connext DDS Secure versions 4.2x to 6.1.0, and Connext DDS Micro versions 2.4 and later are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic. This may result in a denial-of-service condition and information exposure.;RTI Connext DDS;05/05/2022 15:18;75;HIGH;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The attacker can exploit the system's lack of control over resource allocation by flooding it with requests, leading to a denial of service.;Vulners
CODE423N4:2021-07-CONNEXT-FINDINGS-ISSUES-72;Assets are transferred if the execute call fails;"# Handle

shw

# Vulnerability details

## Impact

When the user calls fulfill with a non-zero callTo parameter, the TransactionManager tries to call execute on callTo, and if the function call fails, the manager transfers toSend amount of receiving assets to receivingAddress. However, since the assets may have been transferred before (when the addFunds call fails), the user could get twice the toSend amount assets as a result.

## Proof of Concept

Referenced code:  
[TransactionManager.sol#L405-L408](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L405-L408>)  
[TransactionManager.sol#L424-L427](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L424-L427>)

## Recommended Mitigation Steps

Since the assets are approved or transferred to the receivingAddress before calling the execute function, the manager should not transfer assets again if the execute call fails...";RTI Connext DDS;12/07/2021 00:00;0;;;CWE-476: NULL Pointer Dereference;The vulnerability occurs because the code does not properly handle the case when the function call `execute on callTo` fails. This can lead to a NULL pointer dereference if `callTo` is NULL, which could cause the application to crash. While the description doesn't explicitly state `callTo` can be NULL, the failure to handle the function call failing suggests a lack of NULL check, a common cause of CWE-476.;Vulners
CODE423N4:2021-07-CONNEXT-FINDINGS-ISSUES-47;Expired transfers will lock user funds on the sending chain;"# Handle

0xRajeev

# Vulnerability details

## Impact

The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present) then the cancel transaction from the relayer will always revert and userï¿½s funds will remain locked on the sending chain.

Impact: Expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.

#[Proof of Concept](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517)

## Tools Used

Manual Analysis

## Recommended Mitigation Steps

Change receivingAssetId to sendingAssetId in transferAsset() on L514...";RTI Connext DDS;11/07/2021 00:00;0;;;CWE-20;This vulnerability falls under CWE-20: Improper Input Validation. The code fails to properly validate or sanitize the asset ID used for the cancellation transaction fee, leading to a potential denial-of-service.;Vulners
CODE423N4:2021-07-CONNEXT-FINDINGS-ISSUES-37;The fallback receiver address could get twice the toSend amount;"# Handle

s1m0

# Vulnerability details

In that [block](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L394-L430) of code there are 2 external call inside a try/catch statements.  
In both the catch the toSend amount is transferred to the fallback receiver address effectively transferring twice if the 2 external call fail.

## Impact

In the [fulfill()](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L303>) function the fallback receiver address could get twice the [toSend](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) amount.

## Tools Used

Manual analysis.

## Recommended Mitigation Steps

A possible mitigation would be to return in the 1 catch and revert in the 2 catch...";RTI Connext DDS;11/07/2021 00:00;0;;;CWE-20;This vulnerability aligns with CWE-20: Improper Input Validation. The code fails to adequately validate the success or failure of the external calls within the try/catch blocks. This lack of validation, specifically checking return values or status codes from the external calls, allows the execution flow to proceed to the fallback transfer even when one of the calls fails. ;Vulners
CODE423N4:2021-07-CONNEXT-FINDINGS-ISSUES-38;Logic error in fulfill() function;"# Handle

s1m0

# Vulnerability details

The [fulfill()](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L303>) function could create a loss for the protocol in case [addFunds()](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L396>) succeed and [execute()](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L414>) function fails.

## Impact

In the [fulfill()](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L303>) function the [toSend](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) amount could be transferred twice:

  1. In the external call [addFunds()](<https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L396>) to the txData.callTo.
  2...";RTI Connext DDS;11/07/2021 00:00;0;;;CWE-20;This vulnerability appears to be an example of CWE-20: Improper Input Validation, as the code fails to adequately validate the success or failure of the `execute()` function after a successful `addFunds()` call, potentially leading to a double transfer.;Vulners
CODE423N4:2021-07-CONNEXT-FINDINGS-ISSUES-1;receive funds 2x;"# Handle

gpersoon

# Vulnerability details

## Impact

When the function fulfill tries to call the functions of a receiving contract (callTo) and toSend &gt;0:  
it first calls addFunds and if that fails that it transfers the funds via transferAsset  
it secondly calls execute and if that fails that it transfers the funds via transferAsset

Suppose both addFunds and execute fail (because the receivingAddress isn't a contract or it doesn't have these functions or it reverts on these functions),  
then transferAsset is called twice, thus transferring the funds twice to the receivingAddress.  
You could transfer funds in this way repeatedly to drain all the funds of the router.

## Proof of Concept

// <https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L394>  
function fulfill(  
if (toSend &gt; 0) {  
try IFulfillHelper(txData.callTo).addFunds{ .....";RTI Connext DDS;09/07/2021 00:00;0;;;CWE-20;This vulnerability falls under CWE-20: Improper Input Validation, as the code doesn't adequately validate or handle the scenario where both 'addFunds' and 'execute' functions fail. This lack of validation leads to the 'transferAsset' function being called twice, resulting in a double transfer vulnerability.;Vulners
RTI_CONNEXT_DDS_2017-A-0097.NASL;RTI Connext DDS 5.1.1.x < 5.1.1.5 / 5.2.3.x < 5.2.3.17 / 5.2.7 Multiple Vulnerabilities;"The version of Real Time Innovations (RTI) Connext Data Distribution Service (DDS) installed on the remote Windows host is 5.1.1.x prior to 5.1.1.5 or 5.2.3.x prior to either 5.2.3.17 or 5.2.7. It is, therefore, affected by multiple vulnerabilities :

  - A heap-based buffer overflow condition exists that     allows an unauthenticated, remote attacker to execute     arbitrary code with system privileges.

  - An integer overflow condition exists that allows an     unauthenticated, remote attacker to execute arbitrary     code with system privileges.

  - A deserialization issue exists due to improper     validation of user-supplied data...";RTI Connext DDS;19/04/2017 00:00;0;NONE;;CWE-120;This vulnerability encompasses buffer overflows (heap-based) and integer overflows, which fall under the broader category of 'Classic Buffer Overflow'. CWE-120 addresses vulnerabilities where data written to a buffer exceeds its capacity, potentially overwriting adjacent memory and leading to code execution.;Vulners
RTI_CONNEXT_DDS_WIN_INSTALLED.NBIN;RTI Connext DDS Installed;Real Time Innovations (RTI) Connext Data Distribution Service (DDS) is installed on the remote host. RTI Connext DDS is a connectivity platform for Industrial Internet of Things (IIoT) systems.;RTI Connext DDS;19/04/2017 00:00;0;NONE;;CWE-668;The product's description indicates it's a connectivity platform for IIoT, implying it might be used in sensitive environments without explicitly stating its security posture. This lack of clarity could lead to inappropriate deployment in high-risk settings.;Vulners
CVELIST:CVE-2024-25724;CVE-2024-25724;"In RTI Connext Professional 5.3.1 through 6.1.0 before 6.1.1, a buffer overflow in XML parsing from Routing Service, Recording Service, Queuing Service, and Cloud Discovery Service allows attackers to execute code with the affected service's privileges, compromise the service's integrity, leak sensitive information, or crash the service. These attacks could be done via a remote malicious RTPS message; a compromised call with malicious parameters to the RTI_RoutingService_new, rti::recording::Service, RTI_QueuingService_new, or RTI_CDS_Service_new public APIs; or a compromised local file system containing a malicious XML file....";RTI Connext DDS;21/05/2024 00:00;73;HIGH;;CWE-120;This vulnerability involves a buffer overflow during XML parsing, a classic example of improper input validation that can lead to code execution. ;Vulners
VULNRICHMENT:CVE-2024-25724;CVE-2024-25724;"In RTI Connext Professional 5.3.1 through 6.1.0 before 6.1.1, a buffer overflow in XML parsing from Routing Service, Recording Service, Queuing Service, and Cloud Discovery Service allows attackers to execute code with the affected service's privileges, compromise the service's integrity, leak sensitive information, or crash the service. These attacks could be done via a remote malicious RTPS message; a compromised call with malicious parameters to the RTI_RoutingService_new, rti::recording::Service, RTI_QueuingService_new, or RTI_CDS_Service_new public APIs; or a compromised local file system containing a malicious XML file....";RTI Connext DDS;21/05/2024 00:00;73;HIGH;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input) occurs when data is copied from an input buffer to an output buffer without verifying that the input data fits within the output buffer. In this case, the vulnerability lies in the XML parsing functionality, allowing attackers to send overly large XML data, leading to a buffer overflow.;Vulners
NVD:CVE-2024-30915;CVE-2024-30915;An issue was discovered in OpenDDS commit b1c534032bb62ad4ae32609778de6b8d6c823a66, allows a local attacker to cause a denial of service and obtain sensitive information via the max_samples parameter within the DataReaderQoS component.;OpenDDS;11/04/2024 06:15;43;MEDIUM;;CWE-120;The vulnerability lies in the improper handling of the 'max_samples' parameter, potentially leading to a buffer overflow, which falls under CWE-120 (Classic Buffer Overflow). By manipulating this parameter, an attacker could write data beyond allocated memory bounds, causing a crash (denial of service) or potentially exposing sensitive information.;Vulners
CVE-2024-30915;CVE-2024-30915;An issue was discovered in OpenDDS commit b1c534032bb62ad4ae32609778de6b8d6c823a66, allows a local attacker to cause a denial of service and obtain sensitive information via the max_samples parameter within the DataReaderQoS component.;OpenDDS;11/04/2024 06:15;43;MEDIUM;;CWE-426: Untrusted Search Path;The description does not mention anything about search paths, therefore this is not the correct CWE.  The description mentions a denial of service and information disclosure caused by a specific parameter ('max_samples'). This aligns with resource consumption vulnerabilities where manipulating input related to resource handling can lead to DoS.  A more appropriate category would be **CWE-400: Uncontrolled Resource Consumption** which encompasses vulnerabilities that allow an attacker to exhaust system resources.;Vulners
VULNRICHMENT:CVE-2024-30915;CVE-2024-30915;An issue was discovered in OpenDDS commit b1c534032bb62ad4ae32609778de6b8d6c823a66, allows a local attacker to cause a denial of service and obtain sensitive information via the max_samples parameter within the DataReaderQoS component.;OpenDDS;11/04/2024 00:00;0;NONE;;CWE-120;This vulnerability involves a buffer overflow, where the 'max_samples' parameter in the DataReaderQoS component can be manipulated to exceed the allocated buffer size, leading to a denial of service or potentially leaking sensitive information.;Vulners
CVELIST:CVE-2024-30915;CVE-2024-30915;An issue was discovered in OpenDDS commit b1c534032bb62ad4ae32609778de6b8d6c823a66, allows a local attacker to cause a denial of service and obtain sensitive information via the max_samples parameter within the DataReaderQoS component.;OpenDDS;11/04/2024 00:00;0;NONE;;CWE-400;This vulnerability involves a resource consumption issue (denial of service) due to improper handling of the 'max_samples' parameter, potentially allowing excessive resource allocation and exhaustion.;Vulners
CVE-2023-52427;CVE-2023-52427;In OpenDDS through 3.27, there is a segmentation fault for a DataWriter with a large value of resource_limits.max_samples. NOTE: the vendor's position is that the product is not designed to handle a max_samples value that is too large for the amount of memory on the system.;OpenDDS;11/02/2024 04:15;75;HIGH;;CWE-787;This vulnerability likely falls under CWE-787: Out-of-bounds Write. The description indicates that a large value for 'resource_limits.max_samples' leads to a segmentation fault, which is a strong indicator of an out-of-bounds write. Essentially, the software is trying to write data beyond the allocated memory space.;Vulners
NVD:CVE-2023-52427;CVE-2023-52427;In OpenDDS through 3.27, there is a segmentation fault for a DataWriter with a large value of resource_limits.max_samples. NOTE: the vendor's position is that the product is not designed to handle a max_samples value that is too large for the amount of memory on the system.;OpenDDS;11/02/2024 04:15;75;HIGH;;CWE-787;This vulnerability likely falls under CWE-787: Out-of-bounds Write, as the description suggests that a large 'max_samples' value, exceeding system memory limits, leads to a segmentation fault. This indicates an attempt to write data beyond the allocated memory buffer.;Vulners
PRION:CVE-2023-52427;Memory corruption;In OpenDDS through 3.27, there is a segmentation fault for a DataWriter with a large value of resource_limits.max_samples. NOTE: the vendor's position is that the product is not designed to handle a max_samples value that is too large for the amount of memory on the system.;OpenDDS;11/02/2024 04:15;50;;;CWE-787: Out-of-bounds Write;The vulnerability occurs because the software allows a 'resource_limits.max_samples' value exceeding the system's memory capacity. This could lead to writing data beyond the allocated buffer, resulting in a segmentation fault.;Vulners
VULNRICHMENT:CVE-2023-52427;CVE-2023-52427;In OpenDDS through 3.27, there is a segmentation fault for a DataWriter with a large value of resource_limits.max_samples. NOTE: the vendor's position is that the product is not designed to handle a max_samples value that is too large for the amount of memory on the system.;OpenDDS;11/02/2024 00:00;0;NONE;;CWE-787;CWE-787 (Out-of-bounds Write) occurs when data is written past the boundaries of a buffer. In this case, a large value for 'resource_limits.max_samples' likely leads to OpenDDS attempting to write data beyond the allocated memory, triggering the segmentation fault.;Vulners
CVELIST:CVE-2023-52427;CVE-2023-52427;In OpenDDS through 3.27, there is a segmentation fault for a DataWriter with a large value of resource_limits.max_samples. NOTE: the vendor's position is that the product is not designed to handle a max_samples value that is too large for the amount of memory on the system.;OpenDDS;11/02/2024 00:00;0;NONE;;CWE-787;The vulnerability occurs because the software allows an excessively large value for 'resource_limits.max_samples', potentially leading to writing outside of allocated memory bounds when handling data samples.;Vulners
NVD:CVE-2023-37915;CVE-2023-37915;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS crashes while parsing a malformed `PID_PROPERTY_LIST` in a DATA submessage during participant discovery. Attackers can remotely crash OpenDDS processes by sending a DATA submessage containing the malformed parameter to the known multicast port. This issue has been addressed in version 3.25. Users are advised to upgrade. There are no known workarounds for this vulnerability.;OpenDDS;21/07/2023 21:15;75;HIGH;;CWE-20;This vulnerability falls under CWE-20: Improper Input Validation. OpenDDS fails to properly validate the 'PID_PROPERTY_LIST' parameter in a DATA submessage, allowing an attacker to send malformed data that leads to a crash.;Vulners
CVE-2023-37915;CVE-2023-37915;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS crashes while parsing a malformed `PID_PROPERTY_LIST` in a DATA submessage during participant discovery. Attackers can remotely crash OpenDDS processes by sending a DATA submessage containing the malformed parameter to the known multicast port. This issue has been addressed in version 3.25. Users are advised to upgrade. There are no known workarounds for this vulnerability.;OpenDDS;21/07/2023 21:15;75;HIGH;;CWE-120;This vulnerability is a classic example of a buffer overflow. The software is crashing because it doesn't properly handle a malformed 'PID_PROPERTY_LIST' which is likely too large or structured incorrectly. This leads to data being written outside of the allocated buffer.;Vulners
OSV:CVE-2023-37915;CVE-2023-37915;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS crashes while parsing a malformed `PID_PROPERTY_LIST` in a DATA submessage during participant discovery. Attackers can remotely crash OpenDDS processes by sending a DATA submessage containing the malformed parameter to the known multicast port. This issue has been addressed in version 3.25. Users are advised to upgrade. There are no known workarounds for this vulnerability.;OpenDDS;21/07/2023 21:15;75;HIGH;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs as OpenDDS crashes due to lack of proper validation for the size of the parsed `PID_PROPERTY_LIST`, leading to a potential buffer overflow when handling a malformed parameter.;Vulners
PRION:CVE-2023-37915;Design/Logic Flaw;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS crashes while parsing a malformed `PID_PROPERTY_LIST` in a DATA submessage during participant discovery. Attackers can remotely crash OpenDDS processes by sending a DATA submessage containing the malformed parameter to the known multicast port. This issue has been addressed in version 3.25. Users are advised to upgrade. There are no known workarounds for this vulnerability.;OpenDDS;21/07/2023 21:15;50;;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs as the software doesn't properly control the boundaries when parsing the `PID_PROPERTY_LIST` parameter leading to a crash when a malformed data is sent.;Vulners
CVELIST:CVE-2023-37915;CVE-2023-37915 Malformed PID_PROPERTY_LIST parameter in DATA submessage remotely crashes OpenDDS;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS crashes while parsing a malformed `PID_PROPERTY_LIST` in a DATA submessage during participant discovery. Attackers can remotely crash OpenDDS processes by sending a DATA submessage containing the malformed parameter to the known multicast port. This issue has been addressed in version 3.25. Users are advised to upgrade. There are no known workarounds for this vulnerability.;OpenDDS;21/07/2023 20:02;75;HIGH;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when data is written past the boundaries of a fixed-size buffer, leading to a crash or potentially allowing for arbitrary code execution. In this case, the malformed `PID_PROPERTY_LIST` parameter causes a buffer overflow during parsing.;Vulners
OSV:CVE-2023-23932;CVE-2023-23932;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS applications that are exposed to untrusted RTPS network traffic may crash when parsing badly-formed input. This issue has been patched in version 3.23.1.;OpenDDS;03/02/2023 21:15;75;HIGH;;CWE-20;CWE-20 (Improper Input Validation) occurs because the software doesn't properly validate the RTPS network traffic, allowing badly-formed input to cause a crash. ;Vulners
CVE-2023-23932;CVE-2023-23932;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS applications that are exposed to untrusted RTPS network traffic may crash when parsing badly-formed input. This issue has been patched in version 3.23.1.;OpenDDS;03/02/2023 21:15;75;HIGH;;CWE-120;CWE-120, or 'Buffer Copy without Checking Size of Input', describes vulnerabilities where data is copied to a buffer without ensuring the input fits within the allocated space. This can lead to crashes, as seen in the OpenDDS case, or potentially allow attackers to overwrite critical data.;Vulners
NVD:CVE-2023-23932;CVE-2023-23932;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS applications that are exposed to untrusted RTPS network traffic may crash when parsing badly-formed input. This issue has been patched in version 3.23.1.;OpenDDS;03/02/2023 21:15;75;HIGH;;CWE-120;This vulnerability stems from improper input validation, particularly when handling RTPS network traffic. CWE-120, 'Buffer Copy without Checking Size of Input', broadly covers scenarios where data is copied without verifying if it exceeds the allocated buffer, leading to potential crashes.;Vulners
PRION:CVE-2023-23932;Input validation;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS applications that are exposed to untrusted RTPS network traffic may crash when parsing badly-formed input. This issue has been patched in version 3.23.1.;OpenDDS;03/02/2023 21:15;50;;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input), also known as a 'classic buffer overflow'. The vulnerability occurs because the software does not properly control the amount of data copied from an untrusted source into a fixed-size buffer, potentially leading to a crash.;Vulners
CVELIST:CVE-2023-23932;CVE-2023-23932 Specially crafted RTPS message may cause an OpenDDS application to crash;OpenDDS is an open source C++ implementation of the Object Management Group (OMG) Data Distribution Service (DDS). OpenDDS applications that are exposed to untrusted RTPS network traffic may crash when parsing badly-formed input. This issue has been patched in version 3.23.1.;OpenDDS;03/02/2023 20:08;53;MEDIUM;;CWE-20;CWE-20 (Improper Input Validation) occurs when the software does not validate or incorrectly validates input before using it. In this case, OpenDDS doesn't properly validate the RTPS network traffic, making it vulnerable to crashes from malformed input.;Vulners
OSV:CVE-2021-38445;CVE-2021-38445;OCI OpenDDS versions prior to 3.18.1 do not handle a length parameter consistent with the actual length of the associated data, which may allow an attacker to remotely execute arbitrary code.;OpenDDS;05/05/2022 17:15;75;;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when data written to a buffer exceeds the buffer's capacity, potentially overwriting adjacent memory locations. In this case, the inconsistent handling of the length parameter could allow an attacker to send malicious data exceeding the expected length, leading to a buffer overflow.;Vulners
NVD:CVE-2021-38447;CVE-2021-38447;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition.;OpenDDS;05/05/2022 17:15;75;HIGH;;CWE-476;This vulnerability falls under CWE-476: NULL Pointer Dereference. While the description mentions a specially crafted packet causing a denial of service, it's highly probable that this packet triggers unexpected behavior in the application, potentially leading to a NULL pointer dereference and subsequent crash.;Vulners
CVE-2021-38445;CVE-2021-38445;OCI OpenDDS versions prior to 3.18.1 do not handle a length parameter consistent with the actual length of the associated data, which may allow an attacker to remotely execute arbitrary code.;OpenDDS;05/05/2022 17:15;98;CRITICAL;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when data written to a buffer exceeds the buffer's capacity, potentially overwriting adjacent memory locations. In this case, OpenDDS doesn't properly validate the length parameter, allowing for data larger than the allocated buffer to be processed, leading to a buffer overflow.;Vulners
OSV:CVE-2021-38429;CVE-2021-38429;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition and information exposure.;OpenDDS;05/05/2022 17:15;64;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description indicates a specially crafted packet can cause excessive resource usage (flooding with traffic), leading to a denial of service.;Vulners
OSV:CVE-2021-38447;CVE-2021-38447;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition.;OpenDDS;05/05/2022 17:15;43;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption.  The description highlights that a specially crafted packet can lead to excessive traffic, indicating a lack of control over resource usage and potentially causing a denial-of-service.;Vulners
CVE-2021-38447;CVE-2021-38447;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition.;OpenDDS;05/05/2022 17:15;86;HIGH;;CWE-400;This vulnerability falls under CWE-400, Uncontrolled Resource Consumption, as it allows an attacker to flood the target device with traffic, exhausting its resources and leading to a denial of service.;Vulners
CVE-2021-38429;CVE-2021-38429;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition and information exposure.;OpenDDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description indicates that specially crafted packets can cause the software to consume excessive resources (bandwidth), leading to a denial of service.;Vulners
NVD:CVE-2021-38445;CVE-2021-38445;OCI OpenDDS versions prior to 3.18.1 do not handle a length parameter consistent with the actual length of the associated data, which may allow an attacker to remotely execute arbitrary code.;OpenDDS;05/05/2022 17:15;98;CRITICAL;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when a program doesn't properly check the size of data written to a buffer, potentially allowing an attacker to overwrite adjacent memory locations, leading to crashes or, in worse cases, remote code execution.;Vulners
NVD:CVE-2021-38429;CVE-2021-38429;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition and information exposure.;OpenDDS;05/05/2022 17:15;91;CRITICAL;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description indicates that the vulnerability allows an attacker to flood devices with traffic, which is a classic example of resource exhaustion leading to denial of service.;Vulners
PRION:CVE-2021-38447;Race condition;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition.;OpenDDS;05/05/2022 17:15;43;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description highlights that a specially crafted packet can cause the software to consume excessive resources (network bandwidth), leading to a denial of service.;Vulners
PRION:CVE-2021-38429;Design/Logic Flaw;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition and information exposure.;OpenDDS;05/05/2022 17:15;64;;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The attacker can send a specially crafted packet, leading to the target device being flooded with unwanted traffic. This excessive resource consumption can cause a denial-of-service condition.;Vulners
PRION:CVE-2021-38445;Code injection;OCI OpenDDS versions prior to 3.18.1 do not handle a length parameter consistent with the actual length of the associated data, which may allow an attacker to remotely execute arbitrary code.;OpenDDS;05/05/2022 17:15;75;;;CWE-120;CWE-120 (Buffer Copy without Checking Size of Input Data) refers to cases where data is copied into a fixed-size buffer without proper verification that the data size fits within the buffer's limits. This can lead to buffer overflows, potentially allowing for arbitrary code execution.;Vulners
CVELIST:CVE-2021-38429;CVE-2021-38429 OCI OpenDDS Secure Network Amplification;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition and information exposure.;OpenDDS;05/05/2022 15:26;66;MEDIUM;;CWE-400;Uncontrolled Resource Consumption (Resource Exhaustion) occurs when an attacker can force a system to consume more resources than intended, potentially leading to a denial of service.  In this case, specially crafted packets are used to flood the target, consuming its resources and disrupting service.;Vulners
CVELIST:CVE-2021-38447;CVE-2021-38447 OCI OpenDDS Secure  Amplification;OCI OpenDDS versions prior to 3.18.1 are vulnerable when an attacker sends a specially crafted packet to flood target devices with unwanted traffic, which may result in a denial-of-service condition.;OpenDDS;05/05/2022 15:18;86;HIGH;;CWE-400;This vulnerability falls under CWE-400: Uncontrolled Resource Consumption. The description highlights that an attacker can exploit the system by sending crafted packets leading to excessive resource usage (network bandwidth), effectively causing a denial of service.;Vulners
CVELIST:CVE-2021-38445;CVE-2021-38445 OCI OpenDDS Secure  Improper Handling of Length Parameter Inconsistency;OCI OpenDDS versions prior to 3.18.1 do not handle a length parameter consistent with the actual length of the associated data, which may allow an attacker to remotely execute arbitrary code.;OpenDDS;05/05/2022 15:17;70;HIGH;;CWE-120;CWE-120 (Classic Buffer Overflow) occurs when the software does not perform sufficient bounds checking, allowing data to be written past the allocated buffer, potentially leading to code execution.;Vulners
id,title,description,vendor,published,cvss_score,severity,cwe_category,cwe_explanation,cause,impact,source
id,title,description,vendor,published,cvss_score,severity,cwe_category,cwe_explanation,cause,impact,source
id,title,description,vendor,published,cvss_score,severity,cwe_category,cwe_explanation,cause,impact,source
id,title,description,vendor,published,cvss_score,severity,cwe_category,cwe_explanation,cause,impact,source
